#separator:tab
#html:true
#deck:pgx-lower MLIR Architecture
#notetype:Basic

What are the 4 core MLIR dialects in pgx-lower and their main purposes?	<b>RelAlg</b>: Declarative relational algebra operations (joins, selections, aggregations)<br><b>SubOp</b>: Imperative execution with explicit state management<br><b>DB</b>: Database primitives, types, and NULL handling<br><b>DSA</b>: Data structure abstractions for LLVM lowering

What is the complete dialect transformation pipeline in pgx-lower?	PostgreSQL AST → RelAlg → SubOp → DB → DSA → LLVM IR → JIT

What does "5 > NULL" return in SQL's three-valued logic and why?	<b>UNKNOWN</b><br><br>SQL uses three-valued logic: TRUE, FALSE, and UNKNOWN. Any comparison with NULL returns UNKNOWN, which is treated as FALSE in WHERE clauses.

What is the fundamental difference between RelAlg and SubOp programming paradigms?	<b>RelAlg</b>: Declarative - specifies <i>what</i> to compute using mathematical relational algebra<br><b>SubOp</b>: Imperative - specifies <i>how</i> to compute using explicit state containers and lifecycle management

What are the two phases of a hash join and which SubOp operation handles probing?	<b>Build phase</b>: Create hash table from smaller relation<br><b>Probe phase</b>: Look up keys from larger relation using <b>LookupOp</b>

What is column folding optimization?	Elimination of computed columns that are never used in the final result, dramatically reducing unnecessary computation.<br><br>Example: SELECT name FROM (SELECT name, expensive_calc(x) FROM table) - the expensive_calc is eliminated.

What are SubOp state containers and give 3 examples with their types?	Typed data structures for storing intermediate results:<br><b>!subop.buffer&lt;[...]&gt;</b>: Growable array of tuples<br><b>!subop.map&lt;[key],[value]&gt;</b>: Hash table for lookups<br><b>!subop.array&lt;[...]&gt;</b>: Fixed-size array

What advanced join optimization algorithms does RelAlg support?	<b>DPHyp</b>: Dynamic Programming with Hypergraphs for optimal join ordering<br><b>GOO</b>: Genetic Optimization Operator using evolutionary algorithms<br><b>Predicate pushdown</b>: Moving WHERE conditions closer to data sources

Name 3 specific RelAlg operations and their SQL equivalents	<b>BaseTableOp</b>: FROM table_name<br><b>MapOp</b>: SELECT expressions (computed columns)<br><b>InnerJoinOp</b>: INNER JOIN with ON conditions

What is MILESTONE v1.0 and why is it significant?	Complete elimination of segmentation faults and achievement of stable MLIR integration. This established a foundation for systematic development with debuggable failures instead of crashes.

What are the current test results and main challenges?	<b>Working</b>: Tests 1-7 (basic queries, table scans, simple projections)<br><b>Failing</b>: Tests 8-15 due to LLVM module verification failures and PostgreSQL memory context issues with LOAD commands

What DB dialect operations handle NULL semantics?	<b>db.as_nullable</b>: Convert value to nullable type<br><b>db.isnull</b>: Test if value is NULL (IS NULL operator)<br><b>db.null</b>: Create NULL values<br><b>db.compare</b>: Handle three-valued logic in comparisons

Why does SubOp need explicit state management when RelAlg doesn't?	<b>RelAlg</b>: Declarative - describes relationships without specifying storage<br><b>SubOp</b>: Imperative - needs actual memory locations and lifecycle control for intermediate results during execution

What does AggregationOp represent and how does it lower to SubOp?	Represents SQL GROUP BY with aggregate functions.<br><br>Lowers to: GenericCreateOp (hash map) → MaterializeOp (group tuples) → ScanOp (iterate groups) → MaterializeOp (collect results)

What is the role of the DSA dialect in code generation?	Bridges database operations to LLVM by providing concrete implementations: hash tables, sorting algorithms, memory layouts that LLVM can generate efficient machine code for.