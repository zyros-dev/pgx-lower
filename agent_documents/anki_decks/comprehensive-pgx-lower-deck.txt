#separator:tab
#html:true
#deck:pgx-lower Comprehensive Architecture
#notetype:Basic

What are the 4 core MLIR dialects in pgx-lower and their main purposes?	<b>RelAlg</b>: Declarative relational algebra operations (joins, selections, aggregations)<br><b>SubOp</b>: Imperative execution with explicit state management<br><b>DB</b>: Database primitives, types, and NULL handling<br><b>DSA</b>: Data structure abstractions for LLVM lowering

What is the complete dialect transformation pipeline in pgx-lower?	PostgreSQL AST ‚Üí RelAlg ‚Üí SubOp ‚Üí DB ‚Üí DSA ‚Üí LLVM IR ‚Üí JIT

What does "5 > NULL" return in SQL's three-valued logic and why?	<b>UNKNOWN</b><br><br>SQL uses three-valued logic: TRUE, FALSE, and UNKNOWN. Any comparison with NULL returns UNKNOWN, which is treated as FALSE in WHERE clauses.

What is the fundamental difference between RelAlg and SubOp programming paradigms?	<b>RelAlg</b>: Declarative - specifies <i>what</i> to compute using mathematical relational algebra<br><b>SubOp</b>: Imperative - specifies <i>how</i> to compute using explicit state containers and lifecycle management

What are the two phases of a hash join and which SubOp operation handles probing?	<b>Build phase</b>: Create hash table from smaller relation<br><b>Probe phase</b>: Look up keys from larger relation using <b>LookupOp</b>

What is column folding optimization and provide an example?	Elimination of computed columns that are never used in the final result, dramatically reducing unnecessary computation.<br><br>Example: <code>SELECT name FROM (SELECT name, expensive_calc(x) FROM table)</code> - the expensive_calc is eliminated.

What are SubOp state containers and give 3 examples with their types?	Typed data structures for storing intermediate results:<br><b>!subop.buffer&lt;[...]&gt;</b>: Growable array of tuples<br><b>!subop.map&lt;[key],[value]&gt;</b>: Hash table for lookups<br><b>!subop.array&lt;[...]&gt;</b>: Fixed-size array

What advanced join optimization algorithms does RelAlg support?	<b>DPHyp</b>: Dynamic Programming with Hypergraphs for optimal join ordering<br><b>GOO</b>: Genetic Optimization Operator using evolutionary algorithms<br><b>Predicate pushdown</b>: Moving WHERE conditions closer to data sources

What is MILESTONE v1.0 and why is it significant?	Complete elimination of segmentation faults and achievement of stable MLIR integration. This established a foundation for systematic development with debuggable failures instead of crashes.

What are the current test results and main challenges?	<b>Working</b>: Tests 1-7 (basic queries, table scans, simple projections)<br><b>Failing</b>: Tests 8-15 due to LLVM module verification failures and PostgreSQL memory context issues with LOAD commands

What does AggregationOp represent and how does it lower to SubOp?	Represents SQL GROUP BY with aggregate functions.<br><br>Lowers to: GenericCreateOp (hash map) ‚Üí MaterializeOp (group tuples) ‚Üí ScanOp (iterate groups) ‚Üí MaterializeOp (collect results)

What is the role of the DSA dialect in code generation?	Bridges database operations to LLVM by providing concrete implementations: hash tables, sorting algorithms, memory layouts that LLVM can generate efficient machine code for.

Name the 5 core files in src/core/ and their purposes	<b>mlir_runner.cpp</b>: Main MLIR execution engine (753 lines)<br><b>postgresql_ast_translator.cpp</b>: PostgreSQL AST to MLIR translation (29,548+ tokens)<br><b>query_analyzer.cpp</b>: Query compatibility analysis (469 lines)<br><b>error_handling.cpp</b>: Error management system (182 lines)<br><b>logging.cpp</b>: PostgreSQL-integrated logging (97 lines)

What is the memory context problem and how was it solved in v1.0?	<b>Problem</b>: PostgreSQL LOAD command invalidates memory contexts, breaking MLIR execution<br><b>Solution</b>: Context isolation with global flag <code>g_extension_after_load</code> detection, MLIR context recreation after LOAD, and memory barrier protection

What are the PostgreSQL integration files in src/postgres/?	<b>executor_c.c</b>: PostgreSQL executor hook integration (C)<br><b>executor_c.cpp</b>: C++ executor wrapper and error handling<br><b>my_executor.cpp</b>: Main MLIR execution coordinator<br><b>my_executor.h</b>: Header definitions and interfaces

How does pgx-lower handle result streaming back to PostgreSQL?	Uses <b>TupleStreamer</b> with <code>streamCompletePostgreSQLTuple()</code> that handles dual sources:<br>1. Original table columns via <code>heap_getattr()</code><br>2. Computed expression results via <code>g_computed_results</code><br>Maintains full PostgreSQL type system compatibility

What are the main differences between LingoDB and pgx-lower execution models?	<b>LingoDB</b>: Standalone process, isolated MLIR context, direct table access, predictable memory<br><b>pgx-lower</b>: Embedded in PostgreSQL, shared memory contexts, PostgreSQL heap API, memory context invalidation issues

What is the executor hook system and how does fallback work?	<code>custom_executor()</code> intercepts PostgreSQL queries, calls <code>try_cpp_executor_internal()</code>. If MLIR fails, falls back to <code>standard_ExecutorRun()</code> for graceful degradation.

What are the 3 options proposed for solving AST memory context issues?	<b>Option A</b>: AST Deep Copying - copy nodes to MLIR memory<br><b>Option B</b>: Memory Context Switching - use persistent PostgreSQL contexts<br><b>Option C</b>: Lazy AST Analysis - re-analyze at execution time

What is the test infrastructure structure for pgx-lower?	<b>PostgreSQL Regression Tests</b>: 15 tests in tests/sql/ covering basic to advanced features<br><b>Unit Tests</b>: GoogleTest framework in tests/unit/ for component testing<br><b>Build Targets</b>: make ptest (regression), make utest (unit tests)

What are the 6 main RelAlg operations and their SQL equivalents?	<b>BaseTableOp</b>: FROM table_name<br><b>SelectionOp</b>: WHERE conditions<br><b>MapOp</b>: SELECT expressions (computed columns)<br><b>InnerJoinOp</b>: INNER JOIN with ON conditions<br><b>AggregationOp</b>: GROUP BY with aggregates<br><b>MaterializeOp</b>: Final result formation

What are the 5 key SubOp operations and their purposes?	<b>ScanOp</b>: Sequential scan of state to create tuple streams<br><b>MaterializeOp</b>: Store stream tuples into state<br><b>GenericCreateOp</b>: Create state containers (buffers, maps, arrays)<br><b>LookupOp</b>: Hash table lookups for joins<br><b>NestedMapOp</b>: Iterate over lookup results

What DB dialect operations handle NULL semantics?	<b>db.as_nullable</b>: Convert value to nullable type<br><b>db.isnull</b>: Test if value is NULL (IS NULL operator)<br><b>db.null</b>: Create NULL values<br><b>db.compare</b>: Handle three-valued logic in comparisons<br><b>db.derive_truth</b>: Extract truth values from nullable booleans

How does RelAlg SelectionOp lower to SubOp with optimization?	<b>Predicate Analysis</b>: Break AND conditions into priority-ordered filters<br><b>Priority System</b>: Integer types (1), Date/Decimal (2-3), String (10), Complex (100)<br><b>Filter Chains</b>: Create optimized sequences based on selectivity<br><b>Early Filtering</b>: Reduce downstream processing

What is the current project status and completion percentage?	<b>Phase 5</b>: PostgreSQL Integration (75% complete)<br><b>Tests</b>: 7/15 passing (47%)<br><b>Architecture</b>: ‚úÖ RelAlg ‚úÖ SubOp ‚úÖ DB ‚úÖ DSA üîß LLVM<br><b>Status</b>: MILESTONE v1.0 achieved (segfault elimination)

What are the specific test categories and their status?	<b>Tests 1-3</b>: Basic table scans ‚úÖ PASSING<br><b>Tests 4-7</b>: Data types and simple operations ‚úÖ PASSING<br><b>Tests 8-9</b>: Arithmetic and type operations ‚ùå LLVM verification<br><b>Tests 10-13</b>: Comparisons, logic, NULL, text ‚ùå Memory context<br><b>Tests 14-15</b>: Aggregates and special ops ‚ùå Not implemented

What is the role of TableGen in pgx-lower?	Auto-generates MLIR dialect code from .td files:<br><b>Dialect.{h,cpp}.inc</b>: Dialect registration<br><b>Ops.{h,cpp}.inc</b>: Operation implementations<br><b>Types.{h,cpp}.inc</b>: Type system<br><b>Interfaces.{h,cpp}.inc</b>: Interface definitions<br><b>Enums.{h,cpp}.inc</b>: Enumeration types

What is the directory structure for MLIR dialects in pgx-lower?	<code>include/dialects/{dialect}/</code><br>‚îú‚îÄ‚îÄ {Dialect}Base.td - Base definitions<br>‚îú‚îÄ‚îÄ {Dialect}Ops.td - Operation definitions<br>‚îú‚îÄ‚îÄ {Dialect}Types.td - Type system<br>‚îú‚îÄ‚îÄ {Dialect}Interfaces.td - Interfaces<br>‚îú‚îÄ‚îÄ {Dialect}.h - C++ headers<br>‚îî‚îÄ‚îÄ Conversion/ - Lowering passes

How does DPHyp join optimization work?	<b>Hypergraph Model</b>: Nodes = tables, Hyperedges = multi-table join predicates<br><b>Dynamic Programming</b>: Systematically explore all valid join orders<br><b>Cost-Based Selection</b>: Choose minimum estimated cost order<br><b>Complex Joins</b>: Handle cyclic joins and multi-way predicates

How does GOO (Genetic Optimization) work for join ordering?	<b>Initial Population</b>: Generate random join orders<br><b>Fitness Evaluation</b>: Estimate cost of each order<br><b>Selection</b>: Keep best-performing orders<br><b>Crossover</b>: Combine good orders<br><b>Mutation</b>: Random modifications<br><b>Evolution</b>: Repeat until convergence

What are the key dependencies between MLIR dialects?	<b>Critical Chain</b>: TupleStream ‚Üê SubOp ‚Üê RelAlg<br>‚Üì ‚Üì ‚Üì<br>Util ‚Üê DB ‚Üê RelAlg<br>‚Üì ‚Üì<br>LLVM ‚Üê DSA<br><br><b>Key Dependencies</b>: SubOp‚ÜíDB, DB‚ÜíDSA, DSA‚ÜíLLVM, Util‚ÜíEverything

What is the difference between LingoDB and pgx-lower data sources?	<b>LingoDB</b>: Arrow files, columnar format, reference counting memory<br><b>pgx-lower</b>: PostgreSQL HeapTuples, row format, PostgreSQL memory contexts<br><b>Integration Challenge</b>: Convert between row and columnar processing models

What are the current LLVM IR verification failures?	<b>Problem</b>: MLIR generation succeeds but LLVM verification fails<br><b>Affected Tests</b>: 9, 11, 12, 14, 15 (arithmetic and complex operations)<br><b>Root Cause</b>: Incomplete DB‚ÜíDSA‚ÜíLLVM lowering chain<br><b>Status</b>: Good diagnostics implemented, needs architectural solution

What is the PostgreSQL memory context invalidation issue?	<b>Problem</b>: LOAD command destroys and recreates memory contexts<br><b>Impact</b>: AST node pointers become invalid, causing "null!tuples.tuple" errors<br><b>Affected Tests</b>: 10, 13 (expressions after LOAD)<br><b>Current Solution</b>: Flag-based detection (partial)

What lowering passes transform RelAlg to SubOp to LLVM?	<b>RelAlgToSubOp</b>: Convert declarative operations to imperative state management<br><b>SubOpToControlFlow</b>: Transform state operations to control flow<br><b>MinimalSubOpToControlFlow</b>: Current partial implementation<br><b>StandardToLLVM</b>: Generate LLVM IR from standard MLIR

What are the 3 proposed solutions for memory context problems?	<b>AST Deep Copying</b>: Copy nodes to MLIR memory (complete independence)<br><b>Memory Context Switching</b>: Use persistent PostgreSQL contexts (proper integration)<br><b>Lazy AST Analysis</b>: Re-analyze at execution time (always current)

What is the TupleStreamer and how does it work?	Bridges MLIR computation and PostgreSQL results:<br><b>Input Sources</b>: Original table columns + computed expression results<br><b>Type Preservation</b>: Maintains PostgreSQL type system compatibility<br><b>Dual Format</b>: Handles PostgreSQLTuplePassthrough for seamless integration

What error handling mechanisms does pgx-lower implement?	<b>Exception Boundaries</b>: C++/PostgreSQL boundary management<br><b>Segfault Handler</b>: Backtrace generation for debugging<br><b>PostgreSQL elog</b>: Integration with PostgreSQL logging<br><b>Comprehensive Diagnostics</b>: Module dumps and verification errors

What file contains the main PostgreSQL AST to MLIR translation?	<b>postgresql_ast_translator.cpp</b> (29,548+ tokens)<br>Located in src/core/<br>Handles complex PostgreSQL AST structure translation to RelAlg dialect operations

What is the MapCreationHelper system?	Critical LingoDB compatibility system for column management<br>Enables proper column metadata handling between dialects<br>Required for LingoDB architecture integration<br>Part of successful MILESTONE v1.0 implementation

What are the 15 PostgreSQL regression tests and their focus areas?	<b>1-3</b>: Basic tuple handling<br><b>4-6</b>: Data types and columns<br><b>7-8</b>: Subqueries and type subsets<br><b>9</b>: Arithmetic operations<br><b>10-11</b>: Comparison and logical ops<br><b>12-13</b>: NULL handling and text operations<br><b>14-15</b>: Aggregates and special operators

What is the significance of the "null!tuples.tuple" error?	Indicates PostgreSQL AST memory invalidation after LOAD command<br>Occurs when MLIR tries to access invalidated AST nodes<br>Primary blocker for tests 10, 13 (expression evaluation)<br>Requires AST memory management solution

What build targets are available for testing?	<b>make ptest</b>: Run PostgreSQL regression tests<br><b>make utest</b>: Build and run unit tests<br><b>make utest-run</b>: Run unit tests without rebuild<br><b>make compile_commands</b>: Generate compilation database

What is the relationship between pgx-lower and LingoDB research?	pgx-lower implements LingoDB's proven MLIR architecture within PostgreSQL<br>Maintains full LingoDB dialect hierarchy and optimization algorithms<br>Adapts standalone LingoDB design to embedded PostgreSQL environment<br>Validates LingoDB research in production database setting

What does the query_analyzer.cpp component do?	<b>Lines</b>: 469 lines<br><b>Purpose</b>: Query compatibility analysis and capability detection<br><b>Function</b>: Determines if queries can be handled by MLIR pipeline<br><b>Current Limitation</b>: Expressions disabled to prevent crashes

What is the current status of join operations in pgx-lower?	<b>LingoDB Support</b>: Full join algorithms (DPHyp/GOO) available<br><b>pgx-lower Status</b>: Not yet implemented<br><b>Algorithms Available</b>: Hash joins, nested loops, merge joins<br><b>Planned</b>: Future enhancement after expression issues resolved

What PostgreSQL types are supported in the type system integration?	Full PostgreSQL type system compatibility maintained:<br><b>Primitive</b>: int4, int8, text, numeric, boolean<br><b>Complex</b>: Arrays, composite types, domains<br><b>Nullable Handling</b>: Complete three-valued logic support<br><b>Type Conversion</b>: PostgreSQL ‚Üî MLIR mapping

What is the segfault handler and why is it important?	<code>segfault_handler()</code> in executor_c.c provides:<br><b>Backtrace Generation</b>: Debug information for crashes<br><b>Signal Handling</b>: SIGSEGV interception<br><b>Logging Integration</b>: PostgreSQL elog output<br><b>Historical Importance</b>: Critical for pre-v1.0 debugging

What optimizations are available but not yet enabled?	<b>LingoDB Algorithms</b>: DPHyp/GOO join reordering<br><b>Column Elimination</b>: Remove unused computations<br><b>Predicate Pushdown</b>: Move filters closer to sources<br><b>Vectorization</b>: SIMD operations for arithmetic<br><b>Index Hints</b>: Storage-level optimizations</p>

How does pgx-lower handle the transition from relational to imperative?	<b>RelAlg Level</b>: Mathematical relational algebra (declarative)<br><b>Translation Layer</b>: RelAlgToSubOp lowering pass<br><b>SubOp Level</b>: Explicit state management (imperative)<br><b>Key Change</b>: From "what to compute" to "how to compute"

What is the role of include/runtime/tuple_access.h?	<b>Purpose</b>: PostgreSQL tuple access and streaming<br><b>Key Structure</b>: TupleStreamer for result handling<br><b>Integration</b>: Bridges MLIR and PostgreSQL tuple formats<br><b>Functions</b>: streamCompletePostgreSQLTuple(), type preservation

What are the future enhancement priorities?	<b>Phase 5 Completion</b>: Fix LLVM verification and memory context issues<br><b>Join Operations</b>: Implement hash/nested loop/merge joins<br><b>Advanced Features</b>: Subqueries, CTEs, window functions<br><b>Performance</b>: Enable LingoDB optimizations and vectorization

What is the significance of the unified logging architecture?	<b>PGX_* Macros</b>: DEBUG, INFO, NOTICE, WARNING, ERROR, TRACE<br><b>MLIR Integration</b>: MLIR_PGX_* for dialect-specific logging<br><b>PostgreSQL Compatible</b>: Integrates with PostgreSQL elog system<br><b>Forbidden Patterns</b>: No elog(), llvm::errs(), or printf/cout</p>