#include "mlir/Conversion/DSAToLLVM/DSAToLLVM.h"
#include "execution/logging.h"

#include "mlir/Dialect/DSA/IR/DSAOps.h"
#include "mlir/Dialect/DB/IR/DBOps.h"
#include "mlir/Dialect/RelAlg/IR/RelAlgOps.h"

#include "mlir/Dialect/Arith/IR/Arith.h"
#include "mlir/Dialect/Func/IR/FuncOps.h"
#include "mlir/Dialect/LLVMIR/LLVMDialect.h"
#include "mlir/Dialect/LLVMIR/FunctionCallUtils.h"
#include "mlir/Dialect/SCF/IR/SCF.h"
#include "mlir/Conversion/FuncToLLVM/ConvertFuncToLLVM.h"
#include "mlir/IR/Builders.h"
#include "mlir/IR/BuiltinOps.h"
#include "mlir/IR/BuiltinTypes.h"
#include "mlir/IR/PatternMatch.h"
#include "mlir/Pass/Pass.h"
#include "mlir/Transforms/DialectConversion.h"

#include <llvm/ADT/SmallVector.h>

using namespace mlir;

//===----------------------------------------------------------------------===//
// PHASE 4d-5 - STREAMLINED DSA TO LLVM LOWERING FOR TEST 1
// 
// This pass converts only the DSA operations actually used by Test 1:
// - dsa.create_ds → pgx_runtime_create_table_builder()
// - dsa.ds_append → pgx_runtime_append_nullable_*()
// - dsa.next_row → pgx_runtime_table_next_row()
//
// Removed redundant patterns for operations NOT generated by RelAlgToDB:
// - dsa.scan_source, dsa.for, dsa.yield, dsa.finalize
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// DSA to LLVM Type Converter Implementation
//===----------------------------------------------------------------------===//

mlir::pgx_conversion::DSAToLLVMTypeConverter::DSAToLLVMTypeConverter(MLIRContext *ctx) 
    : LLVMTypeConverter(ctx) {
    MLIR_PGX_DEBUG("DSAToLLVM", "Initializing DSAToLLVMTypeConverter (Phase 4d-5 - Streamlined)");
    
    // PHASE 4d-5: Only convert types actually used by Test 1
    // The hybrid architecture only uses TableBuilderType for internal processing
    
    // Convert DSA TableBuilderType to opaque pointer (runtime handle)
    addConversion([&](::pgx::mlir::dsa::TableBuilderType type) -> Type {
        MLIR_PGX_DEBUG("DSAToLLVM", "Converting DSA TableBuilderType to LLVM pointer");
        return LLVM::LLVMPointerType::get(ctx);
    });
    
    // PHASE 4d-5: Also need to handle nullable types used by DSA operations
    // MaterializeTranslator generates DSA operations with nullable types
    
    // Convert DB nullable types to LLVM struct {value, isNull}
    addConversion([&](::pgx::db::NullableI32Type type) -> Type {
        auto i32Type = IntegerType::get(ctx, 32);
        auto i1Type = IntegerType::get(ctx, 1);
        SmallVector<Type, 2> structTypes = {i32Type, i1Type};
        return LLVM::LLVMStructType::getLiteral(ctx, structTypes);
    });
    
    addConversion([&](::pgx::db::NullableI64Type type) -> Type {
        auto i64Type = IntegerType::get(ctx, 64);
        auto i1Type = IntegerType::get(ctx, 1);
        SmallVector<Type, 2> structTypes = {i64Type, i1Type};
        return LLVM::LLVMStructType::getLiteral(ctx, structTypes);
    });
    
    addConversion([&](::pgx::db::NullableF64Type type) -> Type {
        auto f64Type = Float64Type::get(ctx);
        auto i1Type = IntegerType::get(ctx, 1);
        SmallVector<Type, 2> structTypes = {f64Type, i1Type};
        return LLVM::LLVMStructType::getLiteral(ctx, structTypes);
    });
    
    addConversion([&](::pgx::db::NullableBoolType type) -> Type {
        auto i1Type = IntegerType::get(ctx, 1);
        SmallVector<Type, 2> structTypes = {i1Type, i1Type};
        return LLVM::LLVMStructType::getLiteral(ctx, structTypes);
    });
    
    // Type conversions removed in Phase 4d-5 (not used by Test 1):
    // - GenericIterableType (not generated by RelAlgToDB)
    // - RecordType (not generated by RelAlgToDB)
    // - RecordBatchType (not generated by RelAlgToDB)
    // - TableType (not used - results go directly to PostgreSQL)
}

namespace {


// PHASE 4d-5: Removed redundant DSA patterns not used by Test 1
// The following operations are NOT generated by RelAlgToDB hybrid architecture:
// - dsa.scan_source (not used in PostgreSQL SPI integration)
// - dsa.for / dsa.yield (not used in Test 1)
// - dsa.finalize (hybrid architecture outputs directly to PostgreSQL)

//===----------------------------------------------------------------------===//
// CreateDS Lowering Pattern Implementation
//===----------------------------------------------------------------------===//

class CreateDSToLLVMPattern : public OpConversionPattern<::pgx::mlir::dsa::CreateDS> {
public:
    using OpConversionPattern<::pgx::mlir::dsa::CreateDS>::OpConversionPattern;
    
    LogicalResult matchAndRewrite(::pgx::mlir::dsa::CreateDS op, OpAdaptor adaptor,
                                  ConversionPatternRewriter &rewriter) const override {
        MLIR_PGX_DEBUG("DSAToLLVM", "Converting CreateDS to LLVM runtime call");
        
        auto loc = op.getLoc();
        auto ptrType = LLVM::LLVMPointerType::get(rewriter.getContext());
        
        // PHASE 4d-5: Simplified for Test 1 - only TableBuilder type is used
        if (!op.getType().isa<::pgx::mlir::dsa::TableBuilderType>()) {
            MLIR_PGX_ERROR("DSAToLLVM", "CreateDS for non-TableBuilder type not supported in Test 1");
            return failure();
        }
        
        // Get schema description (always provided by MaterializeTranslator)
        StringRef schemaDesc;
        if (auto attr = op.getInitAttr()) {
            if (auto strAttr = attr->dyn_cast<StringAttr>()) {
                schemaDesc = strAttr.getValue();
            }
        }
        
        // Create runtime call to allocate table builder
        auto funcOpOrError = LLVM::lookupOrCreateFn(
            op->getParentOfType<ModuleOp>(), "pgx_runtime_create_table_builder",
            {ptrType}, ptrType, /*isVarArg=*/false
        );
        
        if (failed(funcOpOrError)) {
            MLIR_PGX_ERROR("DSAToLLVM", "Failed to create pgx_runtime_create_table_builder function");
            return failure();
        }
        
        // Create global string constant for schema description
        Value schemaPtr;
        if (!schemaDesc.empty()) {
            // Add null terminator
            std::string schemaStr = schemaDesc.str();
            schemaStr.push_back('\0');
            
            auto strType = LLVM::LLVMArrayType::get(
                rewriter.getI8Type(), schemaStr.size()
            );
            
            // Generate unique global name
            static int schemaCounter = 0;
            std::string globalName = "dsa_schema_" + std::to_string(schemaCounter++);
            
            // Create global at module level
            auto moduleOp = op->getParentOfType<ModuleOp>();
            auto savedInsertionPoint = rewriter.saveInsertionPoint();
            rewriter.setInsertionPointToStart(moduleOp.getBody());
            
            auto globalOp = rewriter.create<LLVM::GlobalOp>(
                moduleOp.getLoc(), strType, /*isConstant=*/true,
                LLVM::Linkage::Private, globalName,
                rewriter.getStringAttr(schemaStr)
            );
            
            rewriter.restoreInsertionPoint(savedInsertionPoint);
            
            // Get pointer to global
            schemaPtr = rewriter.create<LLVM::AddressOfOp>(
                loc, ptrType, globalOp.getSymNameAttr()
            );
            
            MLIR_PGX_DEBUG("DSAToLLVM", "Created schema global: " + schemaDesc.str());
        } else {
            // No schema - pass null pointer
            schemaPtr = rewriter.create<LLVM::ZeroOp>(loc, ptrType);
            MLIR_PGX_WARNING("DSAToLLVM", "CreateDS without schema description");
        }
        
        // Replace with runtime call
        rewriter.replaceOpWithNewOp<LLVM::CallOp>(
            op, TypeRange{ptrType}, SymbolRefAttr::get(*funcOpOrError), 
            ValueRange{schemaPtr}
        );
        
        MLIR_PGX_DEBUG("DSAToLLVM", "Successfully lowered dsa.create_ds to runtime call");
        return success();
    }
};

//===----------------------------------------------------------------------===//
// Append Lowering Pattern Implementation
//===----------------------------------------------------------------------===//

class DSAppendToLLVMPattern : public OpConversionPattern<::pgx::mlir::dsa::Append> {
public:
    using OpConversionPattern<::pgx::mlir::dsa::Append>::OpConversionPattern;
    
    LogicalResult matchAndRewrite(::pgx::mlir::dsa::Append op, OpAdaptor adaptor,
                                  ConversionPatternRewriter &rewriter) const override {
        MLIR_PGX_DEBUG("DSAToLLVM", "Converting Append to LLVM runtime call");
        
        auto loc = op.getLoc();
        auto ptrType = LLVM::LLVMPointerType::get(rewriter.getContext());
        auto i1Type = rewriter.getI1Type();
        
        // Get converted operands
        auto tableBuilder = adaptor.getDs();
        auto value = adaptor.getVal();
        
        // PHASE 4d-5: Simplified type handling for Test 1
        // MaterializeTranslator only generates nullable types (NullableI32, NullableI64, etc)
        Type valueType = op.getVal().getType();
        std::string funcName;
        
        if (valueType.isa<::pgx::db::NullableI32Type>()) {
            funcName = "pgx_runtime_append_nullable_i32";
        } else if (valueType.isa<::pgx::db::NullableI64Type>()) {
            funcName = "pgx_runtime_append_nullable_i64";
        } else if (valueType.isa<::pgx::db::NullableF64Type>()) {
            funcName = "pgx_runtime_append_nullable_f64";
        } else if (valueType.isa<::pgx::db::NullableBoolType>()) {
            funcName = "pgx_runtime_append_nullable_bool";
        } else {
            // For Test 1, we expect only nullable types from MaterializeTranslator
            std::string typeStr;
            llvm::raw_string_ostream os(typeStr);
            valueType.print(os);
            MLIR_PGX_ERROR("DSAToLLVM", "Unexpected value type in Append: " + typeStr);
            return failure();
        }
        
        // Get the converted value type from the type converter
        auto convertedValueType = getTypeConverter()->convertType(valueType);
        if (!convertedValueType) {
            MLIR_PGX_ERROR("DSAToLLVM", "Failed to convert nullable type");
            return failure();
        }
        
        // Create runtime function call
        // For nullable types, the runtime function handles null checking internally
        auto funcOpOrError = LLVM::lookupOrCreateFn(
            op->getParentOfType<ModuleOp>(), funcName,
            {ptrType, convertedValueType}, 
            LLVM::LLVMVoidType::get(rewriter.getContext()),
            /*isVarArg=*/false
        );
        
        if (failed(funcOpOrError)) {
            MLIR_PGX_ERROR("DSAToLLVM", "Failed to create runtime function: " + funcName);
            return failure();
        }
        
        // Call runtime append function
        rewriter.create<LLVM::CallOp>(
            loc, TypeRange{}, SymbolRefAttr::get(*funcOpOrError), 
            ValueRange{tableBuilder, value}
        );
        
        // Remove original operation
        rewriter.eraseOp(op);
        
        MLIR_PGX_DEBUG("DSAToLLVM", "Successfully lowered dsa.ds_append to " + funcName);
        return success();
    }
};

//===----------------------------------------------------------------------===//
// NextRow Lowering Pattern Implementation
//===----------------------------------------------------------------------===//

class NextRowToLLVMPattern : public OpConversionPattern<::pgx::mlir::dsa::NextRow> {
public:
    using OpConversionPattern<::pgx::mlir::dsa::NextRow>::OpConversionPattern;
    
    LogicalResult matchAndRewrite(::pgx::mlir::dsa::NextRow op, OpAdaptor adaptor,
                                  ConversionPatternRewriter &rewriter) const override {
        MLIR_PGX_DEBUG("DSAToLLVM", "Converting NextRow to LLVM runtime call");
        
        auto loc = op.getLoc();
        auto ptrType = LLVM::LLVMPointerType::get(rewriter.getContext());
        
        // PHASE 4d-5: NextRow completes a row in the internal DSA table builder
        // This is used for organizing data internally, while actual results
        // are streamed to PostgreSQL via db.store_result operations
        
        // Create runtime function to finalize current row
        auto funcOpOrError = LLVM::lookupOrCreateFn(
            op->getParentOfType<ModuleOp>(), "pgx_runtime_table_next_row",
            {ptrType}, LLVM::LLVMVoidType::get(rewriter.getContext()),
            /*isVarArg=*/false
        );
        
        if (failed(funcOpOrError)) {
            MLIR_PGX_ERROR("DSAToLLVM", "Failed to create pgx_runtime_table_next_row function");
            return failure();
        }
        
        // Call runtime function
        rewriter.create<LLVM::CallOp>(
            loc, TypeRange{}, SymbolRefAttr::get(*funcOpOrError), 
            ValueRange{adaptor.getBuilder()}
        );
        
        // Remove original operation
        rewriter.eraseOp(op);
        
        MLIR_PGX_DEBUG("DSAToLLVM", "Successfully lowered dsa.next_row to runtime call");
        return success();
    }
};

// FinalizeOp pattern removed in Phase 4d-5
// Not used in hybrid architecture - results go directly to PostgreSQL via SPI

//===----------------------------------------------------------------------===//
// DSA to LLVM Conversion Pass
//===----------------------------------------------------------------------===//

struct DSAToLLVMPass : public PassWrapper<DSAToLLVMPass, OperationPass<ModuleOp>> {
    MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DSAToLLVMPass)

    void getDependentDialects(DialectRegistry &registry) const override {
        registry.insert<LLVM::LLVMDialect>();
        registry.insert<arith::ArithDialect>();
    }

    StringRef getArgument() const final { return "convert-dsa-to-llvm"; }
    StringRef getDescription() const final { 
        return "Convert DSA dialect operations to LLVM IR"; 
    }

    void runOnOperation() override {
        MLIR_PGX_INFO("DSAToLLVM", "Starting DSA→LLVM conversion (Phase 4d-5 - Streamlined for Test 1)");
        
        auto module = getOperation();
        ConversionTarget target(getContext());
        
        // LLVM dialect is legal
        target.addLegalDialect<LLVM::LLVMDialect>();
        target.addLegalDialect<arith::ArithDialect>();
        
        // DSA dialect is illegal - all operations must be converted
        target.addIllegalDialect<::pgx::mlir::dsa::DSADialect>();
        
        // Allow func operations during conversion
        target.addLegalOp<func::FuncOp>();
        target.addLegalOp<func::ReturnOp>();
        target.addLegalOp<ModuleOp>();
        
        // Initialize type converter
        mlir::pgx_conversion::DSAToLLVMTypeConverter typeConverter(&getContext());
        
        RewritePatternSet patterns(&getContext());
        
        // PHASE 4d-5: Only add patterns for DSA operations used by Test 1
        // The hybrid RelAlgToDB architecture generates only these DSA ops:
        patterns.add<CreateDSToLLVMPattern>(typeConverter, &getContext());   // dsa.create_ds
        patterns.add<DSAppendToLLVMPattern>(typeConverter, &getContext());  // dsa.ds_append
        patterns.add<NextRowToLLVMPattern>(typeConverter, &getContext());   // dsa.next_row
        
        // Removed patterns for operations NOT generated by RelAlgToDB:
        // - ScanSourceToLLVMPattern (dsa.scan_source - not used)
        // - ForOpToLLVMPattern (dsa.for - not used)
        // - YieldOpToLLVMPattern (dsa.yield - not used)
        // - FinalizeToLLVMPattern (dsa.finalize - hybrid uses PostgreSQL SPI)
        
        // Don't convert functions in this pass - focus only on DSA operations
        
        MLIR_PGX_INFO("DSAToLLVM", "Applying DSA→LLVM conversion patterns");
        
        if (failed(applyFullConversion(module, target, std::move(patterns)))) {
            MLIR_PGX_ERROR("DSAToLLVM", "DSA→LLVM conversion failed");
            signalPassFailure();
        } else {
            MLIR_PGX_INFO("DSAToLLVM", "DSA→LLVM conversion completed successfully");
        }
    }
};

} // namespace

namespace mlir {
namespace pgx_conversion {

std::unique_ptr<Pass> createDSAToLLVMPass() {
    return std::make_unique<DSAToLLVMPass>();
}

void registerDSAToLLVMConversionPasses() {
    PassRegistration<DSAToLLVMPass>();
}

} // namespace pgx_conversion
} // namespace mlir