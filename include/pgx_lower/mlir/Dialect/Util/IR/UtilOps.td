#ifndef PGX_DIALECT_UTIL_IR_OPS
#define PGX_DIALECT_UTIL_IR_OPS

include "mlir/IR/OpBase.td"
include "mlir/IR/EnumAttr.td" 
include "mlir/IR/AttrTypeBase.td"
include "mlir/Interfaces/SideEffectInterfaces.td"
include "mlir/IR/BuiltinTypes.td"

//===----------------------------------------------------------------------===//
// Util dialect definition.
//===----------------------------------------------------------------------===//

def Util_Dialect : Dialect {
    let name = "util";
    let summary = "Utility dialect for memory management and tuple operations in pgx-lower";
    let description = [{
        The Util dialect provides fundamental operations for memory management
        and tuple manipulation that are required by higher-level dialects.
        It follows LingoDB patterns adapted for PostgreSQL integration.
    }];
    let cppNamespace = "::pgx::mlir::util";
    
    // REQUIRED: Properties system disabled due to MLIR v20 compatibility issues
    let usePropertiesForAttributes = 0;
    
    // Enable type printing/parsing
    let useDefaultTypePrinterParser = 1;
    
    let extraClassDeclaration = [{
        private:
        void registerTypes();

        public:

    }];
}

//===----------------------------------------------------------------------===//
// Types
//===----------------------------------------------------------------------===//

// Base class for Util types
class Util_Type<string name, string typeMnemonic> : TypeDef<Util_Dialect, name> {
    let mnemonic = typeMnemonic;
}

// Generic reference type for PostgreSQL data
def Util_RefType : TypeDef<Util_Dialect, "Ref"> {
    let mnemonic = "ref";
    let summary = "Generic pointer type for PostgreSQL data";
    let description = [{
        A generic reference type that wraps any type T, providing memory-safe
        access to PostgreSQL data structures. This maps to PostgreSQL pointers
        and integrates with palloc/pfree memory management.
        
        Example:
        ```mlir
        !util.ref<i32>          // Reference to integer
        !util.ref<tuple<i32, i64>>  // Reference to tuple
        ```
    }];
    let parameters = (ins "Type":$elementType);
    let assemblyFormat = "`<` $elementType `>`";
    
    // Don't define getElementType here - it's auto-generated by TableGen
}

//===----------------------------------------------------------------------===//
// Base Util operation definition.
//===----------------------------------------------------------------------===//

class Util_Op<string mnemonic, list<Trait> traits = []> : Op<Util_Dialect, mnemonic, traits> {
}

//===----------------------------------------------------------------------===//
// Memory Management Operations
//===----------------------------------------------------------------------===//

def AllocOp : Util_Op<"alloc", []> {
    let summary = "allocate memory for PostgreSQL data";
    let description = [{
        Allocates memory using PostgreSQL's palloc mechanism. The allocated
        memory is tied to the current memory context and will be freed when
        the context is reset.
        
        Example:
        ```mlir
        %ptr = util.alloc : !util.ref<i32>
        %tuple_ptr = util.alloc : !util.ref<tuple<i32, i64>>
        ```
    }];

    let arguments = (ins);
    let results = (outs Util_RefType:$result);
    let assemblyFormat = "attr-dict `:` type($result)";
}

//===----------------------------------------------------------------------===//
// Tuple Operations
//===----------------------------------------------------------------------===//

def PackOp : Util_Op<"pack", [Pure]> {
    let summary = "create tuple from individual values";
    let description = [{
        Creates a tuple by packing individual values together. This is used
        to construct result tuples for Test 1 and other operations.
        
        Example:
        ```mlir
        %tuple = util.pack %val1, %val2, %val3 : (i32, i64, f32) -> tuple<i32, i64, f32>
        ```
    }];

    let arguments = (ins Variadic<AnyType>:$values);
    let results = (outs TupleOf<[AnyType]>:$result);
    let assemblyFormat = "$values attr-dict `:` `(` type($values) `)` `->` type($result)";
    
    let hasVerifier = 1;
}

def GetTupleOp : Util_Op<"get_tuple", [Pure]> {
    let summary = "extract element from tuple";
    let description = [{
        Extracts an element from a tuple by index. The index must be a constant
        and within the bounds of the tuple.
        
        Example:
        ```mlir
        %elem = util.get_tuple %tuple[1] : tuple<i32, i64, f32> -> i64
        ```
    }];

    let arguments = (ins TupleOf<[AnyType]>:$tuple, I32Attr:$index);
    let results = (outs AnyType:$result);
    let assemblyFormat = "$tuple `[` $index `]` attr-dict `:` type($tuple) `->` type($result)";
    
    let hasVerifier = 1;
}

#endif // PGX_DIALECT_UTIL_IR_OPS