// Phase 4d-6: Integration tests for complete MLIR pipeline
// Tests the full path: RelAlg → DB+DSA → Standard MLIR → LLVM

#include <gtest/gtest.h>
#include "mlir/Dialect/RelAlg/IR/RelAlgOps.h"
#include "mlir/Dialect/DB/IR/DBOps.h"
#include "mlir/Dialect/DSA/IR/DSAOps.h"
#include "mlir/Conversion/RelAlgToDB/RelAlgToDB.h"
#include "mlir/Conversion/DBToStd/DBToStd.h"
#include "mlir/Conversion/DSAToLLVM/DSAToLLVM.h"
#include "mlir/Passes.h"
#include "mlir/Dialect/Func/IR/FuncOps.h"
#include "mlir/Dialect/SCF/IR/SCF.h"
#include "mlir/Dialect/Arith/IR/Arith.h"
#include "mlir/Dialect/MemRef/IR/MemRef.h"
#include "mlir/Dialect/LLVMIR/LLVMDialect.h"
#include "mlir/IR/Builders.h"
#include "mlir/IR/BuiltinOps.h"
#include "mlir/Pass/PassManager.h"
#include "execution/logging.h"

using namespace mlir;

class PipelineIntegrationTest : public ::testing::Test {
protected:
    MLIRContext context;
    std::unique_ptr<OpBuilder> builder;
    
    void SetUp() override {
        // Load all required dialects
        context.loadDialect<pgx::mlir::relalg::RelAlgDialect>();
        context.loadDialect<pgx::db::DBDialect>();
        context.loadDialect<pgx::mlir::dsa::DSADialect>();
        context.loadDialect<func::FuncDialect>();
        context.loadDialect<scf::SCFDialect>();
        context.loadDialect<arith::ArithDialect>();
        context.loadDialect<memref::MemRefDialect>();
        context.loadDialect<LLVM::LLVMDialect>();
        
        builder = std::make_unique<OpBuilder>(&context);
    }
};

// Test the complete pipeline for Test 1: SELECT * FROM test
// Phase 4g-2c: Re-enabled with JIT execution support
TEST_F(PipelineIntegrationTest, Test1CompletePipeline) {
    PGX_DEBUG("Testing complete pipeline for Test 1: SELECT * FROM test");
    
    // Create module and function
    auto loc = builder->getUnknownLoc();
    auto module = ModuleOp::create(loc);
    builder->setInsertionPointToStart(module.getBody());
    
    // Start with RelAlg operations (as generated by parser)
    auto tableType = pgx::mlir::relalg::TableType::get(&context);
    auto funcType = builder->getFunctionType({}, {tableType});
    auto func = builder->create<func::FuncOp>(loc, "test1_pipeline", funcType);
    auto* entryBlock = func.addEntryBlock();
    builder->setInsertionPointToStart(entryBlock);
    
    // Create RelAlg operations for Test 1
    auto tupleStreamType = pgx::mlir::relalg::TupleStreamType::get(&context);
    auto baseTableOp = builder->create<pgx::mlir::relalg::BaseTableOp>(
        loc,
        tupleStreamType,
        builder->getStringAttr("test"),
        builder->getI64IntegerAttr(12345)  // table_oid
    );
    
    auto columnsAttr = builder->getArrayAttr({builder->getStringAttr("id")});
    auto materializeOp = builder->create<pgx::mlir::relalg::MaterializeOp>(
        loc,
        tableType,
        baseTableOp.getResult(),
        columnsAttr
    );
    
    builder->create<func::ReturnOp>(loc, materializeOp.getResult());
    
    // Use the complete lowering pipeline instead of running passes separately
    // This ensures proper type conversion between passes
    PassManager pm(&context);
    mlir::pgx_lower::createCompleteLoweringPipeline(pm, true);
    
    // Check operations before lowering
    int dbOpsBefore = 0, dsaOpsBefore = 0, relalgOpsBefore = 0;
    module.walk([&](Operation* op) {
        if (op->getDialect()) {
            auto ns = op->getDialect()->getNamespace();
            if (ns == "db") dbOpsBefore++;
            else if (ns == "dsa") dsaOpsBefore++;
            else if (ns == "relalg") relalgOpsBefore++;
        }
    });
    
    EXPECT_EQ(dbOpsBefore, 0) << "Should start with no DB operations";
    EXPECT_EQ(dsaOpsBefore, 0) << "Should start with no DSA operations";
    EXPECT_GT(relalgOpsBefore, 0) << "Should start with RelAlg operations";
    
    // Run the complete pipeline
    ASSERT_TRUE(succeeded(pm.run(module))) << "Complete lowering pipeline failed";
    
    // Verify LLVM operations
    bool hasLLVMOps = false;
    module.walk([&](LLVM::CallOp callOp) {
        hasLLVMOps = true;
        auto callee = callOp.getCalleeAttr();
        if (callee) {
            auto funcName = callee.getValue();
            // Verify expected runtime calls
            if (funcName.starts_with("pgx_runtime_")) {
                std::string msg = "Found runtime call: " + funcName.str();
                PGX_DEBUG(msg.c_str());
            }
        }
    });
    
    EXPECT_TRUE(hasLLVMOps) << "Should generate LLVM operations";
    
    // Final verification: no high-level operations remain
    int finalDbOps = 0, finalDsaOps = 0;
    module.walk([&](Operation* op) {
        if (op->getDialect()) {
            auto ns = op->getDialect()->getNamespace();
            if (ns == "db") finalDbOps++;
            else if (ns == "dsa") finalDsaOps++;
        }
    });
    
    // After all lowering passes:
    // - All RelAlg ops should be gone
    // - Some DB ops might remain (PostgreSQL SPI calls) 
    // - All DSA ops should be lowered to LLVM
    EXPECT_EQ(finalDsaOps, 0) << "All DSA operations should be lowered to LLVM";
    // DB operations that remain are intentional (SPI calls)
    if (finalDbOps > 0) {
        PGX_INFO("Remaining DB operations are PostgreSQL SPI calls");
    }
    
    PGX_DEBUG("Complete pipeline test passed");
}

// Test basic pipeline functionality without complex column resolution
TEST_F(PipelineIntegrationTest, BasicPipelineFunction) {
    PGX_DEBUG("Testing basic pipeline functionality");
    
    auto loc = builder->getUnknownLoc();
    auto module = ModuleOp::create(loc);
    builder->setInsertionPointToStart(module.getBody());
    
    // Create simple function without MaterializeOp to avoid column issues
    auto funcType = builder->getFunctionType({}, {});
    auto func = builder->create<func::FuncOp>(loc, "basic_pipeline", funcType);
    auto* entryBlock = func.addEntryBlock();
    builder->setInsertionPointToStart(entryBlock);
    
    // Create simple RelAlg operation
    auto tupleStreamType = pgx::mlir::relalg::TupleStreamType::get(&context);
    auto baseTableOp = builder->create<pgx::mlir::relalg::BaseTableOp>(
        loc,
        tupleStreamType,
        builder->getStringAttr("test"),
        builder->getI64IntegerAttr(12345)
    );
    
    // Just having the operation is enough for this test
    
    builder->create<func::ReturnOp>(loc);
    
    // Phase 1: RelAlg → DB+DSA
    PassManager pm1(&context);
    pm1.addNestedPass<func::FuncOp>(pgx_conversion::createRelAlgToDBPass());
    
    ASSERT_TRUE(succeeded(pm1.run(module))) << "RelAlgToDB pass failed";
    
    // Verify the pass ran successfully
    // BaseTableOp alone doesn't generate DB operations without MaterializeOp
    int relalgOps = 0;
    module.walk([&](Operation* op) {
        if (op->getDialect() && op->getDialect()->getNamespace() == "relalg") {
            relalgOps++;
        }
    });
    
    // BaseTableOp without consumers is not erased
    EXPECT_GT(relalgOps, 0) << "BaseTableOp should remain without MaterializeOp";
    
    PGX_DEBUG("Basic pipeline test passed");
}

// Test error handling throughout the pipeline
TEST_F(PipelineIntegrationTest, ErrorHandlingInPipeline) {
    PGX_DEBUG("Testing error handling in pipeline");
    
    auto loc = builder->getUnknownLoc();
    auto module = ModuleOp::create(loc);
    builder->setInsertionPointToStart(module.getBody());
    
    // Create an empty function (edge case)
    auto funcType = builder->getFunctionType({}, {});
    auto func = builder->create<func::FuncOp>(loc, "empty_query", funcType);
    auto* entryBlock = func.addEntryBlock();
    builder->setInsertionPointToStart(entryBlock);
    builder->create<func::ReturnOp>(loc);
    
    // Run all passes - should handle empty function gracefully
    PassManager pm(&context);
    pm.addNestedPass<func::FuncOp>(pgx_conversion::createRelAlgToDBPass());
    pm.addPass(mlir::createDBToStdPass());
    pm.addPass(pgx_conversion::createDSAToLLVMPass());
    
    ASSERT_TRUE(succeeded(pm.run(module))) << "Pipeline should handle empty functions";
    
    PGX_DEBUG("Error handling test passed");
}

// Test column projection through the pipeline
// Phase 4g-2c: Re-enabled with DBToStd pass
TEST_F(PipelineIntegrationTest, ColumnProjectionPipeline) {
    PGX_DEBUG("Testing column projection through pipeline");
    
    auto loc = builder->getUnknownLoc();
    auto module = ModuleOp::create(loc);
    builder->setInsertionPointToStart(module.getBody());
    
    // Create function with specific column projection
    auto tableType = pgx::mlir::relalg::TableType::get(&context);
    auto funcType = builder->getFunctionType({}, {tableType});
    auto func = builder->create<func::FuncOp>(loc, "projection_test", funcType);
    auto* entryBlock = func.addEntryBlock();
    builder->setInsertionPointToStart(entryBlock);
    
    // Create RelAlg operations with specific column
    auto tupleStreamType = pgx::mlir::relalg::TupleStreamType::get(&context);
    auto baseTableOp = builder->create<pgx::mlir::relalg::BaseTableOp>(
        loc,
        tupleStreamType,
        builder->getStringAttr("test_table"),
        builder->getI64IntegerAttr(12346)
    );
    
    // Project specific column (not *)
    auto columnsAttr = builder->getArrayAttr({builder->getStringAttr("id")});
    auto materializeOp = builder->create<pgx::mlir::relalg::MaterializeOp>(
        loc,
        tableType,
        baseTableOp.getResult(),
        columnsAttr
    );
    
    builder->create<func::ReturnOp>(loc, materializeOp.getResult());
    
    // Run complete pipeline
    PassManager pm(&context);
    pm.addNestedPass<func::FuncOp>(pgx_conversion::createRelAlgToDBPass());
    pm.addPass(mlir::createDBToStdPass());
    pm.addPass(pgx_conversion::createDSAToLLVMPass());
    
    ASSERT_TRUE(succeeded(pm.run(module))) << "Pipeline failed for column projection";
    
    // Verify column-specific operations were generated
    bool foundColumnSpecificOp = false;
    module.walk([&](Operation* op) {
        // Look for operations that reference the column
        for (auto attr : op->getAttrs()) {
            if (auto strAttr = attr.getValue().dyn_cast<StringAttr>()) {
                if (strAttr.getValue().contains("id")) {
                    foundColumnSpecificOp = true;
                }
            }
        }
    });
    
    EXPECT_TRUE(foundColumnSpecificOp) << "Should generate column-specific operations";
    
    PGX_DEBUG("Column projection pipeline test passed");
}

// Test performance characteristics of the pipeline  
// Phase 4g-2c: Re-enabled with DBToStd pass
TEST_F(PipelineIntegrationTest, PipelinePerformanceCharacteristics) {
    PGX_DEBUG("Testing pipeline performance characteristics");
    
    auto loc = builder->getUnknownLoc();
    auto module = ModuleOp::create(loc);
    builder->setInsertionPointToStart(module.getBody());
    
    // Create a more complex query structure
    auto tableType = pgx::mlir::relalg::TableType::get(&context);
    auto funcType = builder->getFunctionType({}, {tableType});
    auto func = builder->create<func::FuncOp>(loc, "perf_test", funcType);
    auto* entryBlock = func.addEntryBlock();
    builder->setInsertionPointToStart(entryBlock);
    
    // Create RelAlg operations
    auto tupleStreamType = pgx::mlir::relalg::TupleStreamType::get(&context);
    auto baseTableOp = builder->create<pgx::mlir::relalg::BaseTableOp>(
        loc,
        tupleStreamType,
        builder->getStringAttr("large_table"),
        builder->getI64IntegerAttr(99999)
    );
    
    auto columnsAttr = builder->getArrayAttr({builder->getStringAttr("id")});
    auto materializeOp = builder->create<pgx::mlir::relalg::MaterializeOp>(
        loc,
        tableType,
        baseTableOp.getResult(),
        columnsAttr
    );
    
    builder->create<func::ReturnOp>(loc, materializeOp.getResult());
    
    // Measure operation counts at each stage
    auto countOps = [&]() {
        std::map<std::string, int> opCounts;
        module.walk([&](Operation* op) {
            if (op->getDialect()) {
                opCounts[op->getDialect()->getNamespace().str()]++;
            }
        });
        return opCounts;
    };
    
    auto initialCounts = countOps();
    
    // Use the complete lowering pipeline
    PassManager pm(&context);
    mlir::pgx_lower::createCompleteLoweringPipeline(pm, true);
    
    // Run the complete pipeline
    auto pipelineStart = std::chrono::high_resolution_clock::now();
    ASSERT_TRUE(succeeded(pm.run(module))) << "Complete pipeline failed";
    auto pipelineEnd = std::chrono::high_resolution_clock::now();
    
    auto finalCounts = countOps();
    
    // Measure pipeline execution time
    auto pipelineDuration = std::chrono::duration_cast<std::chrono::microseconds>(
        pipelineEnd - pipelineStart).count();
    PGX_INFO("Complete pipeline executed in " + std::to_string(pipelineDuration) + " microseconds");
    
    // Verify reasonable operation counts (no explosion)
    int totalOps = 0;
    for (const auto& [dialect, count] : finalCounts) {
        totalOps += count;
        std::string msg = "Final " + dialect + " operations: " + std::to_string(count);
        PGX_DEBUG(msg.c_str());
    }
    
    // The total operation count should be reasonable for Test 1
    EXPECT_LT(totalOps, 100) << "Operation count should not explode";
    
    std::string msg = "Pipeline performance test passed with " + std::to_string(totalOps) + " total operations";
    PGX_DEBUG(msg.c_str());
}