-- Test logical operators: PgAndOp, PgOrOp, PgNotOp
LOAD 'pgx_lower.so';
DROP TABLE IF EXISTS test_logical;
NOTICE:  table "test_logical" does not exist, skipping
CREATE TABLE test_logical (
    id SERIAL PRIMARY KEY,
    flag1 BOOLEAN,
    flag2 BOOLEAN,
    value INTEGER
);
INSERT INTO test_logical(flag1, flag2, value) VALUES 
    (true, false, 10),
    (false, true, 20),
    (true, true, 30),
    (false, false, 40),
    (true, false, 50);
-- Test logical operations in SELECT clauses
-- These should trigger MLIR compilation with logical operators
SELECT (flag1 AND flag2) AS and_result FROM test_logical;
NOTICE:  [PGX-LOWER] Routing through PGX_LOWER compilation
 and_result 
------------
          0
          0
          0
          0
          0
(5 rows)

SELECT (flag1 OR flag2) AS or_result FROM test_logical;
NOTICE:  [PGX-LOWER] Routing through PGX_LOWER compilation
 or_result 
-----------
         0
         0
         0
         0
         0
(5 rows)

SELECT (NOT flag1) AS not_flag1 FROM test_logical;
NOTICE:  [PGX-LOWER] Routing through PGX_LOWER compilation
 not_flag1 
-----------
         0
         1
         0
         1
         0
(5 rows)

SET client_min_messages TO DEBUG1;
SET pgx_lower.log_enable = true;
SET pgx_lower.log_debug = true;
SET pgx_lower.log_trace = true;
SET pgx_lower.enabled_categories = 'RUNTIME';
SELECT (NOT flag2) AS not_flag2 FROM test_logical;
DEBUG:  [GENERAL:DEBUG] Custom executor is being executed in C!
DEBUG:  [GENERAL:DEBUG] Calling C++ executor from C...
DEBUG:  [GENERAL:DEBUG] FORCING tree logging for all queries in comprehensive collection mode
DEBUG:  [AST_TRANSLATE:DEBUG] === POSTGRESQL EXECUTION TREE ===
DEBUG:  [AST_TRANSLATE:DEBUG] SeqScan (type=335) [scanrelid=1]
DEBUG:  [AST_TRANSLATE:DEBUG] === END EXECUTION TREE ===
DEBUG:  [AST_TRANSLATE:DEBUG]  ACCEPTED: Simple SeqScan query
DEBUG:  [AST_TRANSLATE:DEBUG]  Table OID: 10681270
DEBUG:  [AST_TRANSLATE:DEBUG]  Set g_jit_table_oid to: 10681270
DEBUG:  [AST_TRANSLATE:DEBUG]  QUERY ACCEPTED: Proceeding to MLIR compilation pipeline
DEBUG:  [AST_TRANSLATE:DEBUG]  Query features: SELECT+SeqScan+Expressions+CompatibleTypes
DEBUG:  [AST_TRANSLATE:DEBUG]  MLIR COMPATIBLE: Basic SELECT+SeqScan query accepted for compilation
NOTICE:  [PGX-LOWER] Routing through PGX_LOWER compilation
DEBUG:  [GENERAL:DEBUG] === run_mlir_with_ast_translation: Query info ===
DEBUG:  [GENERAL:DEBUG] PlannedStmt ptr: 0x5925fb2cc020
DEBUG:  [GENERAL:DEBUG] planTree ptr: 0x5925fb2cbca0
DEBUG:  [GENERAL:DEBUG] planTree->targetlist ptr: 0x5925fb2cbd80
DEBUG:  [GENERAL:DEBUG] targetlist length: 1
DEBUG:  [GENERAL:DEBUG] Configured for computed expression results
DEBUG:  [RUNTIME:DEBUG] ComputedResultStorage::resize called with numColumns=1
DEBUG:  [RUNTIME:DEBUG] ComputedResultStorage::resize completed, numComputedColumns=1
DEBUG:  [GENERAL:DEBUG] Setting column 0 name to: not_flag2
DEBUG:  [AST_TRANSLATE:DEBUG] Discovered 4 columns for scanrelid 1
DEBUG:  [AST_TRANSLATE:DEBUG] Discovered 4 columns for scanrelid 1
DEBUG:  [AST_TRANSLATE:DEBUG] Checking if translated operation has results
DEBUG:  [AST_TRANSLATE:DEBUG] Operation has 1 results
DEBUG:  [AST_TRANSLATE:DEBUG] Got result from translated operation
DEBUG:  [AST_TRANSLATE:DEBUG] Checking result type
DEBUG:  [AST_TRANSLATE:DEBUG] Result is TupleStreamType, creating MaterializeOp
DEBUG:  [RELALG_LOWER:DEBUG] 

======= Phase 3a BEFORE: RelAlg -> DB+DSA+Util =======
DEBUG:  [RELALG_LOWER:DEBUG] Timestamp: 2025-08-31 15:47:32
DEBUG:  [RELALG_LOWER:DEBUG] Output file: /tmp/pgx_lower_Phase 3a BEFORE: RelAlg -> DB+DSA+Util_20250831_154732.mlir
DEBUG:  [RELALG_LOWER:DEBUG] Module Statistics:
DEBUG:  [RELALG_LOWER:DEBUG]   Total Operations: 10
DEBUG:  [RELALG_LOWER:DEBUG]   Total Blocks: 3
DEBUG:  [RELALG_LOWER:DEBUG]   Total Regions: 3
DEBUG:  [RELALG_LOWER:DEBUG]   Total Values: 6
DEBUG:  [RELALG_LOWER:DEBUG] Operations by Dialect:
DEBUG:  [RELALG_LOWER:DEBUG]   builtin: 1
DEBUG:  [RELALG_LOWER:DEBUG]   db: 2
DEBUG:  [RELALG_LOWER:DEBUG]   func: 2
DEBUG:  [RELALG_LOWER:DEBUG]   relalg: 5
DEBUG:  [RELALG_LOWER:DEBUG] Top Operations by Frequency:
DEBUG:  [RELALG_LOWER:DEBUG]   relalg.return: 1
DEBUG:  [RELALG_LOWER:DEBUG]   relalg.materialize: 1
DEBUG:  [RELALG_LOWER:DEBUG]   relalg.map: 1
DEBUG:  [RELALG_LOWER:DEBUG]   relalg.getcol: 1
DEBUG:  [RELALG_LOWER:DEBUG]   relalg.basetable: 1
DEBUG:  [RELALG_LOWER:DEBUG]   func.return: 1
DEBUG:  [RELALG_LOWER:DEBUG]   func.func: 1
DEBUG:  [RELALG_LOWER:DEBUG]   db.not: 1
DEBUG:  [RELALG_LOWER:DEBUG]   db.derive_truth: 1
DEBUG:  [RELALG_LOWER:DEBUG]   builtin.module: 1
DEBUG:  [RELALG_LOWER:DEBUG] Top Types by Frequency:
DEBUG:  [RELALG_LOWER:DEBUG]   unknowni1: 2
DEBUG:  [RELALG_LOWER:DEBUG]   unknown!relalg.tuplestream: 2
DEBUG:  [RELALG_LOWER:DEBUG]   unknown!dsa.table: 1
DEBUG:  [RELALG_LOWER:DEBUG]   unknown!db.nullable<i1>: 1
DEBUG:  [RELALG_LOWER:DEBUG] Module Verification: PASSED
DEBUG:  [RELALG_LOWER:DEBUG] 
=== MLIR MODULE CONTENT: Phase 3a BEFORE: RelAlg -> DB+DSA+Util ===
  1: module {
  2:   func.func @main() {
  3:     %0 = relalg.basetable  {column_order = ["id", "flag1", "flag2", "value"], table_identifier = "test_logical|oid:10681270"} columns: {flag1 => @test_logical::@flag1({type = !db.nullable<i1>}), flag2 => @test_logical::@flag2({type = !db.nullable<i1>}), id => @test_logical::@id({type = i32}), value => @test_logical::@value({type = !db.nullable<i32>})}
  4:     %1 = relalg.map %0 computes : [@map::@not_flag2({type = i32})] (%arg0: !relalg.tuple){
  5:       %3 = relalg.getcol %arg0 @test_logical::@flag2 : !db.nullable<i1>
  6:       %4 = db.derive_truth %3 : !db.nullable<i1>
  7:       %5 = db.not %4 : i1
  8:       relalg.return %5 : i1
  9:     }
 10:     %2 = relalg.materialize %1 [@map::@not_flag2] => ["not_flag2"] : !dsa.table
 11:     return
 12:   }
 13: }
=== END MLIR MODULE CONTENT ===

DEBUG:  [RELALG_LOWER:DEBUG] Module dumped to: /tmp/pgx_lower_Phase 3a BEFORE: RelAlg -> DB+DSA+Util_20250831_154732.mlir
DEBUG:  [RELALG_LOWER:DEBUG] === End Module Debug Dump ===
DEBUG:  [RELALG_LOWER:DEBUG] 


DEBUG:  [JIT:DEBUG] createRelAlgToDBPipeline: Adding relalg to db pipeline
DEBUG:  [RELALG_LOWER:DEBUG] LowerToDB: Found translation hook for relalg.materialize
DEBUG:  [RELALG_LOWER:DEBUG] Translator::createTranslator called for operation: relalg.materialize
DEBUG:  [RELALG_LOWER:DEBUG] Translator::createTranslator matched MaterializeOp
DEBUG:  [RELALG_LOWER:DEBUG] Translator::createTranslator called for operation: relalg.map
DEBUG:  [RELALG_LOWER:DEBUG] Translator: Base constructor called with Operator
DEBUG:  [RELALG_LOWER:DEBUG] Translator: Getting children from operator
DEBUG:  [RELALG_LOWER:DEBUG] Translator: Creating translator for child operation
DEBUG:  [RELALG_LOWER:DEBUG] Translator::createTranslator called for operation: relalg.basetable
DEBUG:  [RELALG_LOWER:DEBUG] Translator::createTranslator matched BaseTableOp
DEBUG:  [RELALG_LOWER:DEBUG] Translator: Base constructor called with Operator
DEBUG:  [RELALG_LOWER:DEBUG] Translator: Getting children from operator
DEBUG:  [RELALG_LOWER:DEBUG] Translator: Base constructor completed, 0 children
DEBUG:  [RELALG_LOWER:DEBUG] Translator: Base constructor completed, 1 children
DEBUG:  [RELALG_LOWER:DEBUG] LowerToDB: Calling setInfo and produce on translator
DEBUG:  [RELALG_LOWER:DEBUG] MaterializeOp::produce called
DEBUG:  [RELALG_LOWER:DEBUG] MaterializeOp: Calling child[0]->produce
DEBUG:  [RELALG_LOWER:DEBUG] MapOp::produce called - calling child produce
DEBUG:  [RELALG_LOWER:DEBUG] BaseTableOp::produce called - registering columns
DEBUG:  [RELALG_LOWER:DEBUG] BaseTableOp: Processing nullable column index 0 - atOp.getValid() will be inverted with NotOp
DEBUG:  [RELALG_LOWER:DEBUG] MapOp::consume called - processing map operation
DEBUG:  [JIT:DEBUG] MapOp: Merging relational block to compute map expressions
DEBUG:  [JIT:DEBUG] MapOp: Registering 1 computed columns
DEBUG:  [RELALG_LOWER:DEBUG] MapOp: Calling consumer->consume
DEBUG:  [RELALG_LOWER:DEBUG] MaterializeOp::consume called
DEBUG:  [RELALG_LOWER:DEBUG] MaterializeOp: Resolving 1 columns
DEBUG:  [RELALG_LOWER:DEBUG] 

======= Phase 3a AFTER: RelAlg -> DB+DSA+Util =======
DEBUG:  [RELALG_LOWER:DEBUG] Timestamp: 2025-08-31 15:47:32
DEBUG:  [RELALG_LOWER:DEBUG] Output file: /tmp/pgx_lower_Phase 3a AFTER: RelAlg -> DB+DSA+Util_20250831_154732.mlir
DEBUG:  [RELALG_LOWER:DEBUG] Module Statistics:
DEBUG:  [RELALG_LOWER:DEBUG]   Total Operations: 18
DEBUG:  [RELALG_LOWER:DEBUG]   Total Blocks: 4
DEBUG:  [RELALG_LOWER:DEBUG]   Total Regions: 4
DEBUG:  [RELALG_LOWER:DEBUG]   Total Values: 10
DEBUG:  [RELALG_LOWER:DEBUG] Operations by Dialect:
DEBUG:  [RELALG_LOWER:DEBUG]   arith: 1
DEBUG:  [RELALG_LOWER:DEBUG]   builtin: 1
DEBUG:  [RELALG_LOWER:DEBUG]   db: 4
DEBUG:  [RELALG_LOWER:DEBUG]   dsa: 10
DEBUG:  [RELALG_LOWER:DEBUG]   func: 2
DEBUG:  [RELALG_LOWER:DEBUG] Top Operations by Frequency:
DEBUG:  [RELALG_LOWER:DEBUG]   dsa.yield: 2
DEBUG:  [RELALG_LOWER:DEBUG]   dsa.for: 2
DEBUG:  [RELALG_LOWER:DEBUG]   db.not: 2
DEBUG:  [RELALG_LOWER:DEBUG]   func.return: 1
DEBUG:  [RELALG_LOWER:DEBUG]   func.func: 1
DEBUG:  [RELALG_LOWER:DEBUG]   dsa.scan_source: 1
DEBUG:  [RELALG_LOWER:DEBUG]   dsa.next_row: 1
DEBUG:  [RELALG_LOWER:DEBUG]   dsa.finalize: 1
DEBUG:  [RELALG_LOWER:DEBUG]   dsa.ds_append: 1
DEBUG:  [RELALG_LOWER:DEBUG]   dsa.create_ds: 1
DEBUG:  [RELALG_LOWER:DEBUG] Top Types by Frequency:
DEBUG:  [RELALG_LOWER:DEBUG]   unknowni1: 6
DEBUG:  [RELALG_LOWER:DEBUG]   unknown!dsa.table_builder<tuple<i32>>: 1
DEBUG:  [RELALG_LOWER:DEBUG]   unknown!dsa.table: 1
DEBUG:  [RELALG_LOWER:DEBUG]   unknown!dsa.iterable<!dsa.record_batch<tuple<i1>>,table_chunk_iterator>: 1
DEBUG:  [RELALG_LOWER:DEBUG]   unknown!db.nullable<i1>: 1
DEBUG:  [RELALG_LOWER:DEBUG] Module Verification: PASSED
DEBUG:  [RELALG_LOWER:DEBUG] 
=== MLIR MODULE CONTENT: Phase 3a AFTER: RelAlg -> DB+DSA+Util ===
  1: module {
  2:   func.func @main() {
  3:     %true = arith.constant true
  4:     %0 = dsa.create_ds("not_flag2:int[32]") -> !dsa.table_builder<tuple<i32>>
  5:     %1 = dsa.scan_source "{ \22table\22: \22test_logical|oid:10681270\22, \22columns\22: [ \22flag2\22] }" : <!dsa.record_batch<tuple<i1>>,table_chunk_iterator>
  6:     dsa.for %arg0 in %1 : !dsa.iterable<!dsa.record_batch<tuple<i1>>,table_chunk_iterator> {
  7:       dsa.for %arg1 in %arg0 : !dsa.record_batch<tuple<i1>> {
  8:         %val, %valid = dsa.at %arg1[0] : <tuple<i1>> -> i1, i1
  9:         %3 = db.not %valid : i1
 10:         %4 = db.as_nullable %val : i1, %3 -> <i1>
 11:         %5 = db.derive_truth %4 : !db.nullable<i1>
 12:         %6 = db.not %5 : i1
 13:         dsa.ds_append %0 : !dsa.table_builder<tuple<i32>>, %6 : i1, %true
 14:         dsa.next_row %0 : <tuple<i32>>
 15:       } {operandSegmentSizes = array<i32: 1, 0, 0>}
 16:     } {operandSegmentSizes = array<i32: 1, 0, 0>}
 17:     %2 = dsa.finalize %0 : !dsa.table_builder<tuple<i32>> -> !dsa.table
 18:     return
 19:   }
 20: }
=== END MLIR MODULE CONTENT ===

DEBUG:  [RELALG_LOWER:DEBUG] Module dumped to: /tmp/pgx_lower_Phase 3a AFTER: RelAlg -> DB+DSA+Util_20250831_154732.mlir
DEBUG:  [RELALG_LOWER:DEBUG] === End Module Debug Dump ===
DEBUG:  [RELALG_LOWER:DEBUG] 


DEBUG:  [DB_LOWER:DEBUG] 

======= Phase 3b BEFORE: DB+DSA -> Standard =======
DEBUG:  [DB_LOWER:DEBUG] Timestamp: 2025-08-31 15:47:32
DEBUG:  [DB_LOWER:DEBUG] Output file: /tmp/pgx_lower_Phase 3b BEFORE: DB+DSA -> Standard_20250831_154732.mlir
DEBUG:  [DB_LOWER:DEBUG] Module Statistics:
DEBUG:  [DB_LOWER:DEBUG]   Total Operations: 18
DEBUG:  [DB_LOWER:DEBUG]   Total Blocks: 4
DEBUG:  [DB_LOWER:DEBUG]   Total Regions: 4
DEBUG:  [DB_LOWER:DEBUG]   Total Values: 10
DEBUG:  [DB_LOWER:DEBUG] Operations by Dialect:
DEBUG:  [DB_LOWER:DEBUG]   arith: 1
DEBUG:  [DB_LOWER:DEBUG]   builtin: 1
DEBUG:  [DB_LOWER:DEBUG]   db: 4
DEBUG:  [DB_LOWER:DEBUG]   dsa: 10
DEBUG:  [DB_LOWER:DEBUG]   func: 2
DEBUG:  [DB_LOWER:DEBUG] Top Operations by Frequency:
DEBUG:  [DB_LOWER:DEBUG]   dsa.yield: 2
DEBUG:  [DB_LOWER:DEBUG]   dsa.for: 2
DEBUG:  [DB_LOWER:DEBUG]   db.not: 2
DEBUG:  [DB_LOWER:DEBUG]   func.return: 1
DEBUG:  [DB_LOWER:DEBUG]   func.func: 1
DEBUG:  [DB_LOWER:DEBUG]   dsa.scan_source: 1
DEBUG:  [DB_LOWER:DEBUG]   dsa.next_row: 1
DEBUG:  [DB_LOWER:DEBUG]   dsa.finalize: 1
DEBUG:  [DB_LOWER:DEBUG]   dsa.ds_append: 1
DEBUG:  [DB_LOWER:DEBUG]   dsa.create_ds: 1
DEBUG:  [DB_LOWER:DEBUG] Top Types by Frequency:
DEBUG:  [DB_LOWER:DEBUG]   unknowni1: 6
DEBUG:  [DB_LOWER:DEBUG]   unknown!dsa.table_builder<tuple<i32>>: 1
DEBUG:  [DB_LOWER:DEBUG]   unknown!dsa.table: 1
DEBUG:  [DB_LOWER:DEBUG]   unknown!dsa.iterable<!dsa.record_batch<tuple<i1>>,table_chunk_iterator>: 1
DEBUG:  [DB_LOWER:DEBUG]   unknown!db.nullable<i1>: 1
DEBUG:  [DB_LOWER:DEBUG] Module Verification: PASSED
DEBUG:  [DB_LOWER:DEBUG] 
=== MLIR MODULE CONTENT: Phase 3b BEFORE: DB+DSA -> Standard ===
  1: module {
  2:   func.func @main() {
  3:     %true = arith.constant true
  4:     %0 = dsa.create_ds("not_flag2:int[32]") -> !dsa.table_builder<tuple<i32>>
  5:     %1 = dsa.scan_source "{ \22table\22: \22test_logical|oid:10681270\22, \22columns\22: [ \22flag2\22] }" : <!dsa.record_batch<tuple<i1>>,table_chunk_iterator>
  6:     dsa.for %arg0 in %1 : !dsa.iterable<!dsa.record_batch<tuple<i1>>,table_chunk_iterator> {
  7:       dsa.for %arg1 in %arg0 : !dsa.record_batch<tuple<i1>> {
  8:         %val, %valid = dsa.at %arg1[0] : <tuple<i1>> -> i1, i1
  9:         %3 = db.not %valid : i1
 10:         %4 = db.as_nullable %val : i1, %3 -> <i1>
 11:         %5 = db.derive_truth %4 : !db.nullable<i1>
 12:         %6 = db.not %5 : i1
 13:         dsa.ds_append %0 : !dsa.table_builder<tuple<i32>>, %6 : i1, %true
 14:         dsa.next_row %0 : <tuple<i32>>
 15:       } {operandSegmentSizes = array<i32: 1, 0, 0>}
 16:     } {operandSegmentSizes = array<i32: 1, 0, 0>}
 17:     %2 = dsa.finalize %0 : !dsa.table_builder<tuple<i32>> -> !dsa.table
 18:     return
 19:   }
 20: }
=== END MLIR MODULE CONTENT ===

DEBUG:  [DB_LOWER:DEBUG] Module dumped to: /tmp/pgx_lower_Phase 3b BEFORE: DB+DSA -> Standard_20250831_154732.mlir
DEBUG:  [DB_LOWER:DEBUG] === End Module Debug Dump ===
DEBUG:  [DB_LOWER:DEBUG] 


DEBUG:  [JIT:DEBUG] [createDBToStandardPipeline]: Adding DB to Standard pipeline (Phase 2a)
DEBUG:  [DB_LOWER:DEBUG] DBToStd: ENTRY createLowerToStdPass
DEBUG:  [DB_LOWER:DEBUG] DBToStdLoweringPass: Constructor ENTRY
DEBUG:  [DB_LOWER:DEBUG] DBToStd: AFTER DBToStdLoweringPass constructor - success
DEBUG:  [JIT:DEBUG] [createDSAToStandardPipeline]: Adding DSA to Standard pipeline (Phase 2b)
DEBUG:  [DSA_LOWER:DEBUG] DSAToStd: ENTRY createLowerToStdPass
DEBUG:  [DSA_LOWER:DEBUG] DSAToStdLoweringPass: Constructor ENTRY
DEBUG:  [DSA_LOWER:DEBUG] DSAToStd: AFTER DSAToStdLoweringPass constructor - success
DEBUG:  [DB_LOWER:DEBUG] 
[DBToStd] ===== PASS ENTRY =====

DEBUG:  [DB_LOWER:DEBUG] DBToStd: ===== PASS ENTRY =====
DEBUG:  [DB_LOWER:DEBUG] [DB] === DBToStd Pass Entry ===
DEBUG:  [DB_LOWER:DEBUG] [DB] Starting DBToStd lowering pass execution
DEBUG:  [DB_LOWER:DEBUG] [DB] Checking this pointer validity
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] Pass object valid, getting module...
DEBUG:  [DB_LOWER:DEBUG] DBToStd: Pass object is valid, proceeding...
DEBUG:  [DB_LOWER:DEBUG] [DB] Getting module operation
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] Module obtained: 0x5925fb34ca60
DEBUG:  [DB_LOWER:DEBUG] [DB] Module operation obtained successfully
DEBUG:  [DB_LOWER:DEBUG] [DB] Context obtained, checking loaded dialects
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] Context obtained, dialect count: 12
DEBUG:  [DB_LOWER:DEBUG] [DB] Checking loaded dialects count: 12
DEBUG:  [DB_LOWER:DEBUG] [DB] Getting util dialect for function helper
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] UtilDialect obtained: 0x5925fb45a7f0
DEBUG:  [DB_LOWER:DEBUG] [DB] UtilDialect obtained successfully
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] Pattern setup complete, starting module conversion
DEBUG:  [DB_LOWER:DEBUG] DBToStd: Starting module conversion
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] Found DB op to convert: db.not at 0x5925fb34da90
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] Found DB op to convert: db.as_nullable at 0x5925fb3a7450
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] Found DB op to convert: db.isnull at 0x5925fb3aaf70
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] Found DB op to convert: db.nullable_get_val at 0x5925fb3ab000
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] Found DB op to convert: db.not at 0x5925fb488590
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] Total DB operations to convert: 5
DEBUG:  [DB_LOWER:DEBUG] [DBToStd]   - db.not
DEBUG:  [DB_LOWER:DEBUG] [DBToStd]   - db.as_nullable
DEBUG:  [DB_LOWER:DEBUG] [DBToStd]   - db.isnull
DEBUG:  [DB_LOWER:DEBUG] [DBToStd]   - db.nullable_get_val
DEBUG:  [DB_LOWER:DEBUG] [DBToStd]   - db.not
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] Module validated, calling applyFullConversion...
DEBUG:  [DB_LOWER:DEBUG] DBToStd: Module validated, applying conversion patterns...
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] Found DSA operation: dsa.create_ds
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] Found DSA operation: dsa.scan_source
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] Found DSA operation: dsa.at
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] Found DB operation: db.not
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] Found DB operation: db.as_nullable
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] Found DB operation: db.isnull
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] Found DB operation: db.nullable_get_val
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] Found DB operation: db.not
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] Found DSA operation: dsa.ds_append
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] Found DSA operation: dsa.next_row
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] Found DSA operation: dsa.yield
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] Found DSA operation: dsa.for
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] Found DSA operation: dsa.yield
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] Found DSA operation: dsa.for
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] Found DSA operation: dsa.finalize
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] Operation counts - DB: 5, DSA: 10, Util: 0
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] Skipping module dump to avoid potential crash
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] About to call applyFullConversion with 74 patterns
DEBUG:  [DB_LOWER:DEBUG] NotOpLowering: Processing NOT operation
DEBUG:  [DB_LOWER:DEBUG] NotOpLowering: Replaced with CmpIOp(eq, input, false)
DEBUG:  [DB_LOWER:DEBUG] NotOpLowering: Processing NOT operation
DEBUG:  [DB_LOWER:DEBUG] NotOpLowering: Replaced with CmpIOp(eq, input, false)
DEBUG:  [DB_LOWER:DEBUG] [DBToStd] applyFullConversion SUCCEEDED
DEBUG:  [DB_LOWER:DEBUG] DBToStd: Conversion completed successfully
DEBUG:  [DB_LOWER:DEBUG]  
DEBUG:  [DB_LOWER:DEBUG] === MLIR MODULE CONTENT: MLIR after DBStandard lowering ===
DEBUG:  [DB_LOWER:DEBUG]   1: module {
DEBUG:  [DB_LOWER:DEBUG]   2:   func.func @main() {
DEBUG:  [DB_LOWER:DEBUG]   3:     %false = arith.constant false
DEBUG:  [DB_LOWER:DEBUG]   4:     %true = arith.constant true
DEBUG:  [DB_LOWER:DEBUG]   5:     %0 = dsa.create_ds("not_flag2:int[32]") -> !dsa.table_builder<tuple<i32>>
DEBUG:  [DB_LOWER:DEBUG]   6:     %1 = dsa.scan_source "{ \22table\22: \22test_logical|oid:10681270\22, \22columns\22: [ \22flag2\22] }" : <!dsa.record_batch<tuple<i1>>,table_chunk_iterator>
DEBUG:  [DB_LOWER:DEBUG]   7:     dsa.for %arg0 in %1 : !dsa.iterable<!dsa.record_batch<tuple<i1>>,table_chunk_iterator> {
DEBUG:  [DB_LOWER:DEBUG]   8:       dsa.for %arg1 in %arg0 : !dsa.record_batch<tuple<i1>> {
DEBUG:  [DB_LOWER:DEBUG]   9:         %val, %valid = dsa.at %arg1[0] : <tuple<i1>> -> i1, i1
DEBUG:  [DB_LOWER:DEBUG]  10:         %3 = arith.andi %valid, %val : i1
DEBUG:  [DB_LOWER:DEBUG]  11:         %4 = arith.cmpi eq, %3, %false : i1
DEBUG:  [DB_LOWER:DEBUG]  12:         dsa.ds_append %0 : !dsa.table_builder<tuple<i32>>, %4 : i1, %true
DEBUG:  [DB_LOWER:DEBUG]  13:         dsa.next_row %0 : <tuple<i32>>
DEBUG:  [DB_LOWER:DEBUG]  14:       } {operandSegmentSizes = array<i32: 1, 0, 0>}
DEBUG:  [DB_LOWER:DEBUG]  15:     } {operandSegmentSizes = array<i32: 1, 0, 0>}
DEBUG:  [DB_LOWER:DEBUG]  16:     %2 = dsa.finalize %0 : !dsa.table_builder<tuple<i32>> -> !dsa.table
DEBUG:  [DB_LOWER:DEBUG]  17:     return
DEBUG:  [DB_LOWER:DEBUG]  18:   }
DEBUG:  [DB_LOWER:DEBUG]  19: }
DEBUG:  [DB_LOWER:DEBUG] === END MLIR MODULE CONTENT ===
DEBUG:  [JIT:DEBUG] Module dumped to: /tmp/pgx_lower_MLIR_after_DBStandard_lowering_20250831_154732.mlir
DEBUG:  [JIT:DEBUG] === End Module Debug Dump ===
DEBUG:  [JIT:DEBUG]  
DEBUG:  [DSA_LOWER:DEBUG] [DSA] ScanSourceLowering: ENTRY
DEBUG:  [DSA_LOWER:DEBUG] [DSA] ScanSourceLowering: Original ScanSource result type check...
DEBUG:  [DSA_LOWER:DEBUG] [DSA] ScanSourceLowering: Original type is GenericIterableType with name: table_chunk_iterator
DEBUG:  [DSA_LOWER:DEBUG] [DSA] Calling rt::DataSourceIteration::start
DEBUG:  [DSA_LOWER:DEBUG] [DSA] Successfully called rt::DataSourceIteration::start
DEBUG:  [DSA_LOWER:DEBUG] [DSA] ScanSourceLowering: Replacing op with i8* pointer
DEBUG:  [DSA_LOWER:DEBUG] [DSA] ForOpLowering: ENTRY
DEBUG:  [DSA_LOWER:DEBUG] [DSA] ForOpLowering: Processing ForOp at unknown location
DEBUG:  [DSA_LOWER:DEBUG] [DSA] ForOpLowering: Original collection type string: unknown!dsa.iterable<!dsa.record_batch<tuple<i1>>,table_chunk_iterator>
DEBUG:  [DSA_LOWER:DEBUG] [DSA] ForOpLowering: ForOp expects induction variable of type: unknown!dsa.record_batch<tuple<i1>>
DEBUG:  [DSA_LOWER:DEBUG] [DSA] ForOpLowering: Collection is GenericIterableType: table_chunk_iterator
DEBUG:  [DSA_LOWER:DEBUG] [DSA] CollectionIterationImpl::getImpl - ENTRY
DEBUG:  [DSA_LOWER:DEBUG] [DSA] CollectionIterationImpl::getImpl - Collection type string: unknown!dsa.iterable<!dsa.record_batch<tuple<i1>>,table_chunk_iterator>
DEBUG:  [DSA_LOWER:DEBUG] [DSA] CollectionIterationImpl::getImpl - GenericIterableType with name: table_chunk_iterator
DEBUG:  [DSA_LOWER:DEBUG] [DSA] CollectionIterationImpl::getImpl - Creating TableIterator2
DEBUG:  [DSA_LOWER:DEBUG] [DSA] ForOpLowering: ENTRY
DEBUG:  [DSA_LOWER:DEBUG] [DSA] ForOpLowering: Processing ForOp at unknown location
DEBUG:  [DSA_LOWER:DEBUG] [DSA] ForOpLowering: Original collection type string: unknown!dsa.record_batch<tuple<i1>>
DEBUG:  [DSA_LOWER:DEBUG] [DSA] ForOpLowering: ForOp expects induction variable of type: unknown!dsa.record<tuple<i1>>
DEBUG:  [DSA_LOWER:DEBUG] [DSA] ForOpLowering: Collection is RecordBatchType
DEBUG:  [DSA_LOWER:DEBUG] [DSA] CollectionIterationImpl::getImpl - ENTRY
DEBUG:  [DSA_LOWER:DEBUG] [DSA] CollectionIterationImpl::getImpl - Collection type string: unknown!dsa.record_batch<tuple<i1>>
DEBUG:  [DSA_LOWER:DEBUG] [DSA] CollectionIterationImpl::getImpl - Creating RecordBatchIterator
DEBUG:  [DSA_LOWER:DEBUG] [DSAToStd] applyFullConversion SUCCEEDED
DEBUG:  [DSA_LOWER:DEBUG]  
DEBUG:  [DSA_LOWER:DEBUG] === MLIR MODULE CONTENT: MLIR after DSAStandard lowering ===
DEBUG:  [DSA_LOWER:DEBUG]   1: module {
DEBUG:  [DSA_LOWER:DEBUG]   2:   func.func private @rt_tablebuilder_build(!util.ref<i8>) -> !util.ref<i8>
DEBUG:  [DSA_LOWER:DEBUG]   3:   func.func private @rt_tablebuilder_nextrow(!util.ref<i8>)
DEBUG:  [DSA_LOWER:DEBUG]   4:   func.func private @rt_tablebuilder_addbool(!util.ref<i8>, i1, i1)
DEBUG:  [DSA_LOWER:DEBUG]   5:   func.func private @rt_datasourceiteration_end(!util.ref<i8>)
DEBUG:  [DSA_LOWER:DEBUG]   6:   func.func private @rt_datasourceiteration_next(!util.ref<i8>)
DEBUG:  [DSA_LOWER:DEBUG]   7:   func.func private @rt_datasourceiteration_access(!util.ref<i8>, !util.ref<i8>)
DEBUG:  [DSA_LOWER:DEBUG]   8:   func.func private @rt_datasourceiteration_isvalid(!util.ref<i8>) -> i1
DEBUG:  [DSA_LOWER:DEBUG]   9:   func.func private @rt_datasourceiteration_start(!util.ref<i8>, !util.varlen32) -> !util.ref<i8>
DEBUG:  [DSA_LOWER:DEBUG]  10:   func.func private @rt_get_execution_context() -> !util.ref<i8>
DEBUG:  [DSA_LOWER:DEBUG]  11:   func.func private @rt_tablebuilder_create(!util.varlen32) -> !util.ref<i8>
DEBUG:  [DSA_LOWER:DEBUG]  12:   func.func @main() {
DEBUG:  [DSA_LOWER:DEBUG]  13:     %c1_i8 = arith.constant 1 : i8
DEBUG:  [DSA_LOWER:DEBUG]  14:     %c7 = arith.constant 7 : index
DEBUG:  [DSA_LOWER:DEBUG]  15:     %c3 = arith.constant 3 : index
DEBUG:  [DSA_LOWER:DEBUG]  16:     %c0 = arith.constant 0 : index
DEBUG:  [DSA_LOWER:DEBUG]  17:     %c1 = arith.constant 1 : index
DEBUG:  [DSA_LOWER:DEBUG]  18:     %true = arith.constant true
DEBUG:  [DSA_LOWER:DEBUG]  19:     %false = arith.constant false
DEBUG:  [DSA_LOWER:DEBUG]  20:     %0 = util.alloca() : <tuple<index, index, index, !util.ref<i8>, !util.ref<i8>, !util.ref<i8>>>
DEBUG:  [DSA_LOWER:DEBUG]  21:     %1 = util.varlen32_create_const "not_flag2:int[32]"
DEBUG:  [DSA_LOWER:DEBUG]  22:     %2 = call @rt_tablebuilder_create(%1) : (!util.varlen32) -> !util.ref<i8>
DEBUG:  [DSA_LOWER:DEBUG]  23:     %3 = call @rt_get_execution_context() : () -> !util.ref<i8>
DEBUG:  [DSA_LOWER:DEBUG]  24:     %4 = util.varlen32_create_const "{ \22table\22: \22test_logical|oid:10681270\22, \22columns\22: [ \22flag2\22] }"
DEBUG:  [DSA_LOWER:DEBUG]  25:     %5 = call @rt_datasourceiteration_start(%3, %4) : (!util.ref<i8>, !util.varlen32) -> !util.ref<i8>
DEBUG:  [DSA_LOWER:DEBUG]  26:     scf.while : () -> () {
DEBUG:  [DSA_LOWER:DEBUG]  27:       %7 = func.call @rt_datasourceiteration_isvalid(%5) : (!util.ref<i8>) -> i1
DEBUG:  [DSA_LOWER:DEBUG]  28:       scf.condition(%7)
DEBUG:  [DSA_LOWER:DEBUG]  29:     } do {
DEBUG:  [DSA_LOWER:DEBUG]  30:       %7 = util.generic_memref_cast %0 : <tuple<index, index, index, !util.ref<i8>, !util.ref<i8>, !util.ref<i8>>> -> <i8>
DEBUG:  [DSA_LOWER:DEBUG]  31:       func.call @rt_datasourceiteration_access(%5, %7) : (!util.ref<i8>, !util.ref<i8>) -> ()
DEBUG:  [DSA_LOWER:DEBUG]  32:       %8 = util.tupleelementptr %0[0] : <tuple<index, index, index, !util.ref<i8>, !util.ref<i8>, !util.ref<i8>>> -> <index>
DEBUG:  [DSA_LOWER:DEBUG]  33:       %9 = util.load %8[] : <index> -> index
DEBUG:  [DSA_LOWER:DEBUG]  34:       %10 = util.tupleelementptr %0[1] : <tuple<index, index, index, !util.ref<i8>, !util.ref<i8>, !util.ref<i8>>> -> <index>
DEBUG:  [DSA_LOWER:DEBUG]  35:       %11 = util.load %10[] : <index> -> index
DEBUG:  [DSA_LOWER:DEBUG]  36:       %12 = util.tupleelementptr %0[3] : <tuple<index, index, index, !util.ref<i8>, !util.ref<i8>, !util.ref<i8>>> -> <!util.ref<i8>>
DEBUG:  [DSA_LOWER:DEBUG]  37:       %13 = util.load %12[] : <!util.ref<i8>> -> !util.ref<i8>
DEBUG:  [DSA_LOWER:DEBUG]  38:       %14 = util.tupleelementptr %0[4] : <tuple<index, index, index, !util.ref<i8>, !util.ref<i8>, !util.ref<i8>>> -> <!util.ref<i8>>
DEBUG:  [DSA_LOWER:DEBUG]  39:       %15 = util.load %14[] : <!util.ref<i8>> -> !util.ref<i8>
DEBUG:  [DSA_LOWER:DEBUG]  40:       %16 = util.tupleelementptr %0[2] : <tuple<index, index, index, !util.ref<i8>, !util.ref<i8>, !util.ref<i8>>> -> <index>
DEBUG:  [DSA_LOWER:DEBUG]  41:       %17 = util.load %16[] : <index> -> index
DEBUG:  [DSA_LOWER:DEBUG]  42:       scf.for %arg0 = %c0 to %9 step %c1 {
DEBUG:  [DSA_LOWER:DEBUG]  43:         %18 = arith.addi %11, %arg0 : index
DEBUG:  [DSA_LOWER:DEBUG]  44:         %19 = arith.shrui %18, %c3 : index
DEBUG:  [DSA_LOWER:DEBUG]  45:         %20 = arith.andi %18, %c7 : index
DEBUG:  [DSA_LOWER:DEBUG]  46:         %21 = util.load %15[%19] : <i8> -> i8
DEBUG:  [DSA_LOWER:DEBUG]  47:         %22 = arith.index_cast %20 : index to i8
DEBUG:  [DSA_LOWER:DEBUG]  48:         %23 = arith.shrui %21, %22 : i8
DEBUG:  [DSA_LOWER:DEBUG]  49:         %24 = arith.andi %23, %c1_i8 : i8
DEBUG:  [DSA_LOWER:DEBUG]  50:         %25 = arith.cmpi eq, %24, %c1_i8 : i8
DEBUG:  [DSA_LOWER:DEBUG]  51:         %26 = arith.muli %17, %arg0 : index
DEBUG:  [DSA_LOWER:DEBUG]  52:         %27 = arith.shrui %26, %c3 : index
DEBUG:  [DSA_LOWER:DEBUG]  53:         %28 = arith.andi %26, %c7 : index
DEBUG:  [DSA_LOWER:DEBUG]  54:         %29 = util.load %13[%27] : <i8> -> i8
DEBUG:  [DSA_LOWER:DEBUG]  55:         %30 = arith.index_cast %28 : index to i8
DEBUG:  [DSA_LOWER:DEBUG]  56:         %31 = arith.shrui %29, %30 : i8
DEBUG:  [DSA_LOWER:DEBUG]  57:         %32 = arith.andi %31, %c1_i8 : i8
DEBUG:  [DSA_LOWER:DEBUG]  58:         %33 = arith.cmpi eq, %32, %c1_i8 : i8
DEBUG:  [DSA_LOWER:DEBUG]  59:         %34 = arith.andi %33, %25 : i1
DEBUG:  [DSA_LOWER:DEBUG]  60:         %35 = arith.cmpi eq, %34, %false : i1
DEBUG:  [DSA_LOWER:DEBUG]  61:         func.call @rt_tablebuilder_addbool(%2, %true, %35) : (!util.ref<i8>, i1, i1) -> ()
DEBUG:  [DSA_LOWER:DEBUG]  62:         func.call @rt_tablebuilder_nextrow(%2) : (!util.ref<i8>) -> ()
DEBUG:  [DSA_LOWER:DEBUG]  63:       }
DEBUG:  [DSA_LOWER:DEBUG]  64:       func.call @rt_datasourceiteration_next(%5) : (!util.ref<i8>) -> ()
DEBUG:  [DSA_LOWER:DEBUG]  65:       scf.yield
DEBUG:  [DSA_LOWER:DEBUG]  66:     }
DEBUG:  [DSA_LOWER:DEBUG]  67:     call @rt_datasourceiteration_end(%5) : (!util.ref<i8>) -> ()
DEBUG:  [DSA_LOWER:DEBUG]  68:     %6 = call @rt_tablebuilder_build(%2) : (!util.ref<i8>) -> !util.ref<i8>
DEBUG:  [DSA_LOWER:DEBUG]  69:     return
DEBUG:  [DSA_LOWER:DEBUG]  70:   }
DEBUG:  [DSA_LOWER:DEBUG]  71: }
DEBUG:  [DSA_LOWER:DEBUG] === END MLIR MODULE CONTENT ===
DEBUG:  [JIT:DEBUG] Module dumped to: /tmp/pgx_lower_MLIR_after_DSAStandard_lowering_20250831_154732.mlir
DEBUG:  [JIT:DEBUG] === End Module Debug Dump ===
DEBUG:  [JIT:DEBUG]  
DEBUG:  [DB_LOWER:DEBUG] 

======= Phase 3b AFTER: DB+DSA -> Standard =======
DEBUG:  [DB_LOWER:DEBUG] Timestamp: 2025-08-31 15:47:32
DEBUG:  [DB_LOWER:DEBUG] Output file: /tmp/pgx_lower_Phase 3b AFTER: DB+DSA -> Standard_20250831_154732.mlir
DEBUG:  [DB_LOWER:DEBUG] Module Statistics:
DEBUG:  [DB_LOWER:DEBUG]   Total Operations: 67
DEBUG:  [DB_LOWER:DEBUG]   Total Blocks: 5
DEBUG:  [DB_LOWER:DEBUG]   Total Regions: 15
DEBUG:  [DB_LOWER:DEBUG]   Total Values: 44
DEBUG:  [DB_LOWER:DEBUG] Operations by Dialect:
DEBUG:  [DB_LOWER:DEBUG]   arith: 23
DEBUG:  [DB_LOWER:DEBUG]   builtin: 1
DEBUG:  [DB_LOWER:DEBUG]   func: 22
DEBUG:  [DB_LOWER:DEBUG]   scf: 5
DEBUG:  [DB_LOWER:DEBUG]   util: 16
DEBUG:  [DB_LOWER:DEBUG] Top Operations by Frequency:
DEBUG:  [DB_LOWER:DEBUG]   func.func: 11
DEBUG:  [DB_LOWER:DEBUG]   func.call: 10
DEBUG:  [DB_LOWER:DEBUG]   util.load: 7
DEBUG:  [DB_LOWER:DEBUG]   arith.constant: 7
DEBUG:  [DB_LOWER:DEBUG]   util.tupleelementptr: 5
DEBUG:  [DB_LOWER:DEBUG]   arith.andi: 5
DEBUG:  [DB_LOWER:DEBUG]   arith.shrui: 4
DEBUG:  [DB_LOWER:DEBUG]   arith.cmpi: 3
DEBUG:  [DB_LOWER:DEBUG]   util.varlen32_create_const: 2
DEBUG:  [DB_LOWER:DEBUG]   scf.yield: 2
DEBUG:  [DB_LOWER:DEBUG] Top Types by Frequency:
DEBUG:  [DB_LOWER:DEBUG]   unknownindex: 13
DEBUG:  [DB_LOWER:DEBUG]   unknowni8: 9
DEBUG:  [DB_LOWER:DEBUG]   unknowni1: 7
DEBUG:  [DB_LOWER:DEBUG]   unknown!util.ref<i8>: 7
DEBUG:  [DB_LOWER:DEBUG]   unknown!util.ref<index>: 3
DEBUG:  [DB_LOWER:DEBUG] Module Verification: PASSED
DEBUG:  [DB_LOWER:DEBUG] 
=== MLIR MODULE CONTENT: Phase 3b AFTER: DB+DSA -> Standard ===
  1: module {
  2:   func.func private @rt_tablebuilder_build(!util.ref<i8>) -> !util.ref<i8>
  3:   func.func private @rt_tablebuilder_nextrow(!util.ref<i8>)
  4:   func.func private @rt_tablebuilder_addbool(!util.ref<i8>, i1, i1)
  5:   func.func private @rt_datasourceiteration_end(!util.ref<i8>)
  6:   func.func private @rt_datasourceiteration_next(!util.ref<i8>)
  7:   func.func private @rt_datasourceiteration_access(!util.ref<i8>, !util.ref<i8>)
  8:   func.func private @rt_datasourceiteration_isvalid(!util.ref<i8>) -> i1
  9:   func.func private @rt_datasourceiteration_start(!util.ref<i8>, !util.varlen32) -> !util.ref<i8>
 10:   func.func private @rt_get_execution_context() -> !util.ref<i8>
 11:   func.func private @rt_tablebuilder_create(!util.varlen32) -> !util.ref<i8>
 12:   func.func @main() {
 13:     %c1_i8 = arith.constant 1 : i8
 14:     %c7 = arith.constant 7 : index
 15:     %c3 = arith.constant 3 : index
 16:     %c0 = arith.constant 0 : index
 17:     %c1 = arith.constant 1 : index
 18:     %true = arith.constant true
 19:     %false = arith.constant false
 20:     %0 = util.alloca() : <tuple<index, index, index, !util.ref<i8>, !util.ref<i8>, !util.ref<i8>>>
 21:     %1 = util.varlen32_create_const "not_flag2:int[32]"
 22:     %2 = call @rt_tablebuilder_create(%1) : (!util.varlen32) -> !util.ref<i8>
 23:     %3 = call @rt_get_execution_context() : () -> !util.ref<i8>
 24:     %4 = util.varlen32_create_const "{ \22table\22: \22test_logical|oid:10681270\22, \22columns\22: [ \22flag2\22] }"
 25:     %5 = call @rt_datasourceiteration_start(%3, %4) : (!util.ref<i8>, !util.varlen32) -> !util.ref<i8>
 26:     scf.while : () -> () {
 27:       %7 = func.call @rt_datasourceiteration_isvalid(%5) : (!util.ref<i8>) -> i1
 28:       scf.condition(%7)
 29:     } do {
 30:       %7 = util.generic_memref_cast %0 : <tuple<index, index, index, !util.ref<i8>, !util.ref<i8>, !util.ref<i8>>> -> <i8>
 31:       func.call @rt_datasourceiteration_access(%5, %7) : (!util.ref<i8>, !util.ref<i8>) -> ()
 32:       %8 = util.tupleelementptr %0[0] : <tuple<index, index, index, !util.ref<i8>, !util.ref<i8>, !util.ref<i8>>> -> <index>
 33:       %9 = util.load %8[] : <index> -> index
 34:       %10 = util.tupleelementptr %0[1] : <tuple<index, index, index, !util.ref<i8>, !util.ref<i8>, !util.ref<i8>>> -> <index>
 35:       %11 = util.load %10[] : <index> -> index
 36:       %12 = util.tupleelementptr %0[3] : <tuple<index, index, index, !util.ref<i8>, !util.ref<i8>, !util.ref<i8>>> -> <!util.ref<i8>>
 37:       %13 = util.load %12[] : <!util.ref<i8>> -> !util.ref<i8>
 38:       %14 = util.tupleelementptr %0[4] : <tuple<index, index, index, !util.ref<i8>, !util.ref<i8>, !util.ref<i8>>> -> <!util.ref<i8>>
 39:       %15 = util.load %14[] : <!util.ref<i8>> -> !util.ref<i8>
 40:       %16 = util.tupleelementptr %0[2] : <tuple<index, index, index, !util.ref<i8>, !util.ref<i8>, !util.ref<i8>>> -> <index>
 41:       %17 = util.load %16[] : <index> -> index
 42:       scf.for %arg0 = %c0 to %9 step %c1 {
 43:         %18 = arith.addi %11, %arg0 : index
 44:         %19 = arith.shrui %18, %c3 : index
 45:         %20 = arith.andi %18, %c7 : index
 46:         %21 = util.load %15[%19] : <i8> -> i8
 47:         %22 = arith.index_cast %20 : index to i8
 48:         %23 = arith.shrui %21, %22 : i8
 49:         %24 = arith.andi %23, %c1_i8 : i8
 50:         %25 = arith.cmpi eq, %24, %c1_i8 : i8
 51:         %26 = arith.muli %17, %arg0 : index
 52:         %27 = arith.shrui %26, %c3 : index
 53:         %28 = arith.andi %26, %c7 : index
 54:         %29 = util.load %13[%27] : <i8> -> i8
 55:         %30 = arith.index_cast %28 : index to i8
 56:         %31 = arith.shrui %29, %30 : i8
 57:         %32 = arith.andi %31, %c1_i8 : i8
 58:         %33 = arith.cmpi eq, %32, %c1_i8 : i8
 59:         %34 = arith.andi %33, %25 : i1
 60:         %35 = arith.cmpi eq, %34, %false : i1
 61:         func.call @rt_tablebuilder_addbool(%2, %true, %35) : (!util.ref<i8>, i1, i1) -> ()
 62:         func.call @rt_tablebuilder_nextrow(%2) : (!util.ref<i8>) -> ()
 63:       }
 64:       func.call @rt_datasourceiteration_next(%5) : (!util.ref<i8>) -> ()
 65:       scf.yield
 66:     }
 67:     call @rt_datasourceiteration_end(%5) : (!util.ref<i8>) -> ()
 68:     %6 = call @rt_tablebuilder_build(%2) : (!util.ref<i8>) -> !util.ref<i8>
 69:     return
 70:   }
 71: }
=== END MLIR MODULE CONTENT ===

DEBUG:  [DB_LOWER:DEBUG] Module dumped to: /tmp/pgx_lower_Phase 3b AFTER: DB+DSA -> Standard_20250831_154732.mlir
DEBUG:  [DB_LOWER:DEBUG] === End Module Debug Dump ===
DEBUG:  [DB_LOWER:DEBUG] 


DEBUG:  [JIT:DEBUG] [createStandardToLLVMPipeline]: Adding DB DSA to Standard pipeline
DEBUG:  [JIT:DEBUG] 

======= Phase 3c BEFORE: Standard -> LLVM =======
DEBUG:  [JIT:DEBUG] Timestamp: 2025-08-31 15:47:32
DEBUG:  [JIT:DEBUG] Output file: /tmp/pgx_lower_Phase 3c BEFORE: Standard -> LLVM_20250831_154732.mlir
DEBUG:  [JIT:DEBUG] Module Statistics:
DEBUG:  [JIT:DEBUG]   Total Operations: 67
DEBUG:  [JIT:DEBUG]   Total Blocks: 5
DEBUG:  [JIT:DEBUG]   Total Regions: 15
DEBUG:  [JIT:DEBUG]   Total Values: 44
DEBUG:  [JIT:DEBUG] Operations by Dialect:
DEBUG:  [JIT:DEBUG]   arith: 23
DEBUG:  [JIT:DEBUG]   builtin: 1
DEBUG:  [JIT:DEBUG]   func: 22
DEBUG:  [JIT:DEBUG]   scf: 5
DEBUG:  [JIT:DEBUG]   util: 16
DEBUG:  [JIT:DEBUG] Top Operations by Frequency:
DEBUG:  [JIT:DEBUG]   func.func: 11
DEBUG:  [JIT:DEBUG]   func.call: 10
DEBUG:  [JIT:DEBUG]   util.load: 7
DEBUG:  [JIT:DEBUG]   arith.constant: 7
DEBUG:  [JIT:DEBUG]   util.tupleelementptr: 5
DEBUG:  [JIT:DEBUG]   arith.andi: 5
DEBUG:  [JIT:DEBUG]   arith.shrui: 4
DEBUG:  [JIT:DEBUG]   arith.cmpi: 3
DEBUG:  [JIT:DEBUG]   util.varlen32_create_const: 2
DEBUG:  [JIT:DEBUG]   scf.yield: 2
DEBUG:  [JIT:DEBUG] Top Types by Frequency:
DEBUG:  [JIT:DEBUG]   unknownindex: 13
DEBUG:  [JIT:DEBUG]   unknowni8: 9
DEBUG:  [JIT:DEBUG]   unknowni1: 7
DEBUG:  [JIT:DEBUG]   unknown!util.ref<i8>: 7
DEBUG:  [JIT:DEBUG]   unknown!util.ref<index>: 3
DEBUG:  [JIT:DEBUG] Module Verification: PASSED
DEBUG:  [JIT:DEBUG] 
=== MLIR MODULE CONTENT: Phase 3c BEFORE: Standard -> LLVM ===
  1: module {
  2:   func.func private @rt_tablebuilder_build(!util.ref<i8>) -> !util.ref<i8>
  3:   func.func private @rt_tablebuilder_nextrow(!util.ref<i8>)
  4:   func.func private @rt_tablebuilder_addbool(!util.ref<i8>, i1, i1)
  5:   func.func private @rt_datasourceiteration_end(!util.ref<i8>)
  6:   func.func private @rt_datasourceiteration_next(!util.ref<i8>)
  7:   func.func private @rt_datasourceiteration_access(!util.ref<i8>, !util.ref<i8>)
  8:   func.func private @rt_datasourceiteration_isvalid(!util.ref<i8>) -> i1
  9:   func.func private @rt_datasourceiteration_start(!util.ref<i8>, !util.varlen32) -> !util.ref<i8>
 10:   func.func private @rt_get_execution_context() -> !util.ref<i8>
 11:   func.func private @rt_tablebuilder_create(!util.varlen32) -> !util.ref<i8>
 12:   func.func @main() {
 13:     %c1_i8 = arith.constant 1 : i8
 14:     %c7 = arith.constant 7 : index
 15:     %c3 = arith.constant 3 : index
 16:     %c0 = arith.constant 0 : index
 17:     %c1 = arith.constant 1 : index
 18:     %true = arith.constant true
 19:     %false = arith.constant false
 20:     %0 = util.alloca() : <tuple<index, index, index, !util.ref<i8>, !util.ref<i8>, !util.ref<i8>>>
 21:     %1 = util.varlen32_create_const "not_flag2:int[32]"
 22:     %2 = call @rt_tablebuilder_create(%1) : (!util.varlen32) -> !util.ref<i8>
 23:     %3 = call @rt_get_execution_context() : () -> !util.ref<i8>
 24:     %4 = util.varlen32_create_const "{ \22table\22: \22test_logical|oid:10681270\22, \22columns\22: [ \22flag2\22] }"
 25:     %5 = call @rt_datasourceiteration_start(%3, %4) : (!util.ref<i8>, !util.varlen32) -> !util.ref<i8>
 26:     scf.while : () -> () {
 27:       %7 = func.call @rt_datasourceiteration_isvalid(%5) : (!util.ref<i8>) -> i1
 28:       scf.condition(%7)
 29:     } do {
 30:       %7 = util.generic_memref_cast %0 : <tuple<index, index, index, !util.ref<i8>, !util.ref<i8>, !util.ref<i8>>> -> <i8>
 31:       func.call @rt_datasourceiteration_access(%5, %7) : (!util.ref<i8>, !util.ref<i8>) -> ()
 32:       %8 = util.tupleelementptr %0[0] : <tuple<index, index, index, !util.ref<i8>, !util.ref<i8>, !util.ref<i8>>> -> <index>
 33:       %9 = util.load %8[] : <index> -> index
 34:       %10 = util.tupleelementptr %0[1] : <tuple<index, index, index, !util.ref<i8>, !util.ref<i8>, !util.ref<i8>>> -> <index>
 35:       %11 = util.load %10[] : <index> -> index
 36:       %12 = util.tupleelementptr %0[3] : <tuple<index, index, index, !util.ref<i8>, !util.ref<i8>, !util.ref<i8>>> -> <!util.ref<i8>>
 37:       %13 = util.load %12[] : <!util.ref<i8>> -> !util.ref<i8>
 38:       %14 = util.tupleelementptr %0[4] : <tuple<index, index, index, !util.ref<i8>, !util.ref<i8>, !util.ref<i8>>> -> <!util.ref<i8>>
 39:       %15 = util.load %14[] : <!util.ref<i8>> -> !util.ref<i8>
 40:       %16 = util.tupleelementptr %0[2] : <tuple<index, index, index, !util.ref<i8>, !util.ref<i8>, !util.ref<i8>>> -> <index>
 41:       %17 = util.load %16[] : <index> -> index
 42:       scf.for %arg0 = %c0 to %9 step %c1 {
 43:         %18 = arith.addi %11, %arg0 : index
 44:         %19 = arith.shrui %18, %c3 : index
 45:         %20 = arith.andi %18, %c7 : index
 46:         %21 = util.load %15[%19] : <i8> -> i8
 47:         %22 = arith.index_cast %20 : index to i8
 48:         %23 = arith.shrui %21, %22 : i8
 49:         %24 = arith.andi %23, %c1_i8 : i8
 50:         %25 = arith.cmpi eq, %24, %c1_i8 : i8
 51:         %26 = arith.muli %17, %arg0 : index
 52:         %27 = arith.shrui %26, %c3 : index
 53:         %28 = arith.andi %26, %c7 : index
 54:         %29 = util.load %13[%27] : <i8> -> i8
 55:         %30 = arith.index_cast %28 : index to i8
 56:         %31 = arith.shrui %29, %30 : i8
 57:         %32 = arith.andi %31, %c1_i8 : i8
 58:         %33 = arith.cmpi eq, %32, %c1_i8 : i8
 59:         %34 = arith.andi %33, %25 : i1
 60:         %35 = arith.cmpi eq, %34, %false : i1
 61:         func.call @rt_tablebuilder_addbool(%2, %true, %35) : (!util.ref<i8>, i1, i1) -> ()
 62:         func.call @rt_tablebuilder_nextrow(%2) : (!util.ref<i8>) -> ()
 63:       }
 64:       func.call @rt_datasourceiteration_next(%5) : (!util.ref<i8>) -> ()
 65:       scf.yield
 66:     }
 67:     call @rt_datasourceiteration_end(%5) : (!util.ref<i8>) -> ()
 68:     %6 = call @rt_tablebuilder_build(%2) : (!util.ref<i8>) -> !util.ref<i8>
 69:     return
 70:   }
 71: }
=== END MLIR MODULE CONTENT ===

DEBUG:  [JIT:DEBUG] Module dumped to: /tmp/pgx_lower_Phase 3c BEFORE: Standard -> LLVM_20250831_154732.mlir
DEBUG:  [JIT:DEBUG] === End Module Debug Dump ===
DEBUG:  [JIT:DEBUG] 


DEBUG:  [JIT:DEBUG] 

======= Phase 3c AFTER: Standard -> LLVM =======
DEBUG:  [JIT:DEBUG] Timestamp: 2025-08-31 15:47:32
DEBUG:  [JIT:DEBUG] Output file: /tmp/pgx_lower_Phase 3c AFTER: Standard -> LLVM_20250831_154732.mlir
DEBUG:  [JIT:DEBUG] Module Statistics:
DEBUG:  [JIT:DEBUG]   Total Operations: 83
DEBUG:  [JIT:DEBUG]   Total Blocks: 8
DEBUG:  [JIT:DEBUG]   Total Regions: 14
DEBUG:  [JIT:DEBUG]   Total Values: 57
DEBUG:  [JIT:DEBUG] Operations by Dialect:
DEBUG:  [JIT:DEBUG]   builtin: 1
DEBUG:  [JIT:DEBUG]   llvm: 82
DEBUG:  [JIT:DEBUG] Top Operations by Frequency:
DEBUG:  [JIT:DEBUG]   llvm.mlir.constant: 11
DEBUG:  [JIT:DEBUG]   llvm.func: 11
DEBUG:  [JIT:DEBUG]   llvm.call: 10
DEBUG:  [JIT:DEBUG]   llvm.load: 7
DEBUG:  [JIT:DEBUG]   llvm.getelementptr: 7
DEBUG:  [JIT:DEBUG]   llvm.and: 5
DEBUG:  [JIT:DEBUG]   llvm.lshr: 4
DEBUG:  [JIT:DEBUG]   llvm.icmp: 4
DEBUG:  [JIT:DEBUG]   llvm.br: 4
DEBUG:  [JIT:DEBUG]   llvm.trunc: 2
DEBUG:  [JIT:DEBUG] Top Types by Frequency:
DEBUG:  [JIT:DEBUG]   unknown!llvm.ptr: 16
DEBUG:  [JIT:DEBUG]   unknowni64: 15
DEBUG:  [JIT:DEBUG]   unknowni8: 9
DEBUG:  [JIT:DEBUG]   unknowni128: 9
DEBUG:  [JIT:DEBUG]   unknowni1: 8
DEBUG:  [JIT:DEBUG] Module Verification: PASSED
DEBUG:  [JIT:DEBUG] 
=== MLIR MODULE CONTENT: Phase 3c AFTER: Standard -> LLVM ===
  1: module {
  2:   llvm.mlir.global private constant @global_str_const_7("{ \22table\22: \22test_logical|oid:10681270\22, \22columns\22: [ \22flag2\22] }") {addr_space = 0 : i32}
  3:   llvm.mlir.global private constant @global_str_const_6("not_flag2:int[32]") {addr_space = 0 : i32}
  4:   llvm.func @rt_tablebuilder_build(!llvm.ptr) -> !llvm.ptr attributes {sym_visibility = "public"}
  5:   llvm.func @rt_tablebuilder_nextrow(!llvm.ptr) attributes {sym_visibility = "public"}
  6:   llvm.func @rt_tablebuilder_addbool(!llvm.ptr, i1, i1) attributes {sym_visibility = "public"}
  7:   llvm.func @rt_datasourceiteration_end(!llvm.ptr) attributes {sym_visibility = "public"}
  8:   llvm.func @rt_datasourceiteration_next(!llvm.ptr) attributes {sym_visibility = "public"}
  9:   llvm.func @rt_datasourceiteration_access(!llvm.ptr, !llvm.ptr) attributes {sym_visibility = "public"}
 10:   llvm.func @rt_datasourceiteration_isvalid(!llvm.ptr) -> i1 attributes {sym_visibility = "public"}
 11:   llvm.func @rt_datasourceiteration_start(!llvm.ptr, i128) -> !llvm.ptr attributes {sym_visibility = "public"}
 12:   llvm.func @rt_get_execution_context() -> !llvm.ptr attributes {sym_visibility = "public"}
 13:   llvm.func @rt_tablebuilder_create(i128) -> !llvm.ptr attributes {sym_visibility = "public"}
 14:   llvm.func @main() attributes {sym_visibility = "public"} {
 15:     %0 = llvm.mlir.addressof @global_str_const_7 : !llvm.ptr
 16:     %1 = llvm.mlir.constant(8368286770260869183 : i128) : i128
 17:     %2 = llvm.mlir.constant(64 : i128) : i128
 18:     %3 = llvm.mlir.addressof @global_str_const_6 : !llvm.ptr
 19:     %4 = llvm.mlir.constant(6878245049138675729 : i128) : i128
 20:     %5 = llvm.mlir.constant(1 : i8) : i8
 21:     %6 = llvm.mlir.constant(7 : index) : i64
 22:     %7 = llvm.mlir.constant(3 : index) : i64
 23:     %8 = llvm.mlir.constant(0 : index) : i64
 24:     %9 = llvm.mlir.constant(1 : index) : i64
 25:     %10 = llvm.mlir.constant(true) : i1
 26:     %11 = llvm.mlir.constant(false) : i1
 27:     %12 = llvm.mlir.constant(48 : i64) : i64
 28:     %13 = llvm.alloca %12 x i8 : (i64) -> !llvm.ptr
 29:     %14 = llvm.ptrtoint %3 : !llvm.ptr to i128
 30:     %15 = llvm.shl %14, %2 : i128
 31:     %16 = llvm.or %4, %15 : i128
 32:     %17 = llvm.call @rt_tablebuilder_create(%16) : (i128) -> !llvm.ptr
 33:     %18 = llvm.call @rt_get_execution_context() : () -> !llvm.ptr
 34:     %19 = llvm.ptrtoint %0 : !llvm.ptr to i128
 35:     %20 = llvm.shl %19, %2 : i128
 36:     %21 = llvm.or %1, %20 : i128
 37:     %22 = llvm.call @rt_datasourceiteration_start(%18, %21) : (!llvm.ptr, i128) -> !llvm.ptr
 38:     llvm.br ^bb1
 39:   ^bb1:  // 2 preds: ^bb0, ^bb5
 40:     %23 = llvm.call @rt_datasourceiteration_isvalid(%22) : (!llvm.ptr) -> i1
 41:     llvm.cond_br %23, ^bb2, ^bb6
 42:   ^bb2:  // pred: ^bb1
 43:     llvm.call @rt_datasourceiteration_access(%22, %13) : (!llvm.ptr, !llvm.ptr) -> ()
 44:     %24 = llvm.getelementptr %13[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<(i64, i64, i64, ptr, ptr, ptr)>
 45:     %25 = llvm.load %24 : !llvm.ptr -> i64
 46:     %26 = llvm.getelementptr %13[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<(i64, i64, i64, ptr, ptr, ptr)>
 47:     %27 = llvm.load %26 : !llvm.ptr -> i64
 48:     %28 = llvm.getelementptr %13[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<(i64, i64, i64, ptr, ptr, ptr)>
 49:     %29 = llvm.load %28 : !llvm.ptr -> !llvm.ptr
 50:     %30 = llvm.getelementptr %13[0, 4] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<(i64, i64, i64, ptr, ptr, ptr)>
 51:     %31 = llvm.load %30 : !llvm.ptr -> !llvm.ptr
 52:     %32 = llvm.getelementptr %13[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<(i64, i64, i64, ptr, ptr, ptr)>
 53:     %33 = llvm.load %32 : !llvm.ptr -> i64
 54:     llvm.br ^bb3(%8 : i64)
 55:   ^bb3(%34: i64):  // 2 preds: ^bb2, ^bb4
 56:     %35 = llvm.icmp "slt" %34, %25 : i64
 57:     llvm.cond_br %35, ^bb4, ^bb5
 58:   ^bb4:  // pred: ^bb3
 59:     %36 = llvm.add %27, %34 : i64
 60:     %37 = llvm.lshr %36, %7 : i64
 61:     %38 = llvm.and %36, %6 : i64
 62:     %39 = llvm.getelementptr %31[%37] : (!llvm.ptr, i64) -> !llvm.ptr, i8
 63:     %40 = llvm.load %39 : !llvm.ptr -> i8
 64:     %41 = llvm.trunc %38 : i64 to i8
 65:     %42 = llvm.lshr %40, %41 : i8
 66:     %43 = llvm.and %42, %5 : i8
 67:     %44 = llvm.icmp "eq" %43, %5 : i8
 68:     %45 = llvm.mul %33, %34 : i64
 69:     %46 = llvm.lshr %45, %7 : i64
 70:     %47 = llvm.and %45, %6 : i64
 71:     %48 = llvm.getelementptr %29[%46] : (!llvm.ptr, i64) -> !llvm.ptr, i8
 72:     %49 = llvm.load %48 : !llvm.ptr -> i8
 73:     %50 = llvm.trunc %47 : i64 to i8
 74:     %51 = llvm.lshr %49, %50 : i8
 75:     %52 = llvm.and %51, %5 : i8
 76:     %53 = llvm.icmp "eq" %52, %5 : i8
 77:     %54 = llvm.and %53, %44 : i1
 78:     %55 = llvm.icmp "eq" %54, %11 : i1
 79:     llvm.call @rt_tablebuilder_addbool(%17, %10, %55) : (!llvm.ptr, i1, i1) -> ()
 80:     llvm.call @rt_tablebuilder_nextrow(%17) : (!llvm.ptr) -> ()
 81:     %56 = llvm.add %34, %9 : i64
 82:     llvm.br ^bb3(%56 : i64)
 83:   ^bb5:  // pred: ^bb3
 84:     llvm.call @rt_datasourceiteration_next(%22) : (!llvm.ptr) -> ()
 85:     llvm.br ^bb1
 86:   ^bb6:  // pred: ^bb1
 87:     llvm.call @rt_datasourceiteration_end(%22) : (!llvm.ptr) -> ()
 88:     %57 = llvm.call @rt_tablebuilder_build(%17) : (!llvm.ptr) -> !llvm.ptr
 89:     llvm.return
 90:   }
 91: }
=== END MLIR MODULE CONTENT ===

DEBUG:  [JIT:DEBUG] Module dumped to: /tmp/pgx_lower_Phase 3c AFTER: Standard -> LLVM_20250831_154732.mlir
DEBUG:  [JIT:DEBUG] === End Module Debug Dump ===
DEBUG:  [JIT:DEBUG] 


DEBUG:  [JIT:DEBUG] Phase 3c: Standard → LLVM lowering completed successfully
DEBUG:  [JIT:DEBUG] Complete MLIR lowering pipeline succeeded: RelAlg → DB+DSA+Util → Standard → LLVM
DEBUG:  [JIT:DEBUG] LLVM target triple: x86_64-pc-linux-gnu
DEBUG:  [JIT:DEBUG] Registering PostgreSQL runtime functions
DEBUG:  [JIT:DEBUG] Registering C runtime functions
DEBUG:  [JIT:DEBUG] Registered 13 runtime functions
DEBUG:  [JIT:DEBUG] Registering PostgreSQL runtime functions
DEBUG:  [JIT:DEBUG] Registering C runtime functions
DEBUG:  [JIT:DEBUG] Registered 13 runtime functions
DEBUG:  [JIT:DEBUG] JIT execution handle created successfully
DEBUG:  [JIT:DEBUG] Executing function at: 0x791df54e4000
DEBUG:  [JIT:DEBUG] Setting execution context via rt_set_execution_context
DEBUG:  [JIT:DEBUG] estate pointer value: 0x5925fb2e3820
DEBUG:  [JIT:DEBUG] Execution context set successfully
DEBUG:  [JIT:DEBUG] About to execute JIT-compiled function
DEBUG:  [RUNTIME:DEBUG] rt_tablebuilder_create: initialized with dynamic column tracking
DEBUG:  [RUNTIME:DEBUG] rt_get_execution_context called
DEBUG:  [RUNTIME:DEBUG] rt_get_execution_context returning g_execution_context: 0x5925fb2e3820
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_start called with context: 0x5925fb2e3820, varlen32_param len: 63
DEBUG:  [RUNTIME:DEBUG] decode_table_specification: LingoDB VarLen32 len=63
DEBUG:  [RUNTIME:DEBUG] decode_table_specification: JSON string: { "table": "test_logical|oid:10681270", "columns": [ "flag2"] }
DEBUG:  [RUNTIME:DEBUG] decode_table_specification: valid JSON detected, parsing...
DEBUG:  [RUNTIME:DEBUG] parse_table_spec: parsing JSON: { "table": "test_logical|oid:10681270", "columns": [ "flag2"] }
DEBUG:  [RUNTIME:DEBUG] parse_table_spec: table=test_logical|oid:10681270, columns=1
DEBUG:  [RUNTIME:DEBUG] decode_table_specification: JSON parsed successfully - table 'test_logical' with 1 columns
DEBUG:  [RUNTIME:DEBUG] initialize_column_storage: configured for table 'test_logical' with 1 columns
DEBUG:  [RUNTIME:DEBUG] open_postgres_table called with tableName: test_logical
DEBUG:  [RUNTIME:DEBUG] open_postgres_table: Creating PostgreSQLTableHandle...
DEBUG:  [RUNTIME:DEBUG] open_postgres_table: JIT-managed table access, opening table: test_logical
DEBUG:  [RUNTIME:DEBUG] open_postgres_table: Using table OID: 10681270
DEBUG:  [RUNTIME:DEBUG] open_postgres_table: Successfully opened table with OID 10681270
DEBUG:  [RUNTIME:DEBUG] open_postgres_table: Calling heap_rescan...
DEBUG:  [RUNTIME:DEBUG] open_postgres_table: scanDesc=0x5925fb2e4390, tupleDesc=0x791df52646f0
DEBUG:  [RUNTIME:DEBUG] open_postgres_table: tupleDesc->natts=4
DEBUG:  [RUNTIME:DEBUG] open_postgres_table: scanning relation OID=10681270, name=test_logical
DEBUG:  [RUNTIME:DEBUG] open_postgres_table: Updating scan with fresh snapshot xmin=53748, xmax=53748
DEBUG:  [RUNTIME:DEBUG] open_postgres_table: Successfully created handle, returning 0x5925fb2e2180
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_start returning iterator: 0x5925fb2e4150
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid called with iterator: 0x5925fb2e4150
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid: iter=0x5925fb2e4150, table_handle=0x5925fb2e2180
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid: About to call read_next_tuple_from_table
DEBUG:  [RUNTIME:TRACE] read_next_tuple_from_table: About to call heap_getnext with scanDesc=0x5925fb2e4390
DEBUG:  [RUNTIME:TRACE] read_next_tuple_from_table: scanDesc->rs_rd=0x791df525e7f0, snapshot=0x5925fb229ae0
DEBUG:  [RUNTIME:TRACE] read_next_tuple_from_table: heap_getnext completed, tuple=0x5925fb2e43e8
DEBUG:  [RUNTIME:TRACE] read_next_tuple_from_table: About to process tuple, cleaning up previous tuple
DEBUG:  [RUNTIME:TRACE] read_next_tuple_from_table: Tuple preserved for streaming
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid: read_result = 1
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid: column 0 (flag2) from PG column 2 = false (null=false)
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid finished running with: 0x5925fb2e4150 branch 2
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access called with iterator: 0x5925fb2e4150, row_data: 0x7ffc1f5e3258
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access: row_data is valid, proceeding
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access: handling 1 columns
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access: column 0 is_null=false, valid_bitmap=0xFF
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access: column 0 (flag2) boolean = false at 0x5925fb48ad80
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access: configured 1 columns successfully
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access completed successfully
DEBUG:  [RUNTIME:TRACE] table_builder_add<bool>: byte value=0xFF (255), normalized=1
DEBUG:  [RUNTIME:DEBUG] table_builder_add: storing value at column index 0 with is_null=false
DEBUG:  [RUNTIME:DEBUG] rt_tablebuilder_nextrow: LingoDB column validation passed - 1 columns filled
DEBUG:  [RUNTIME:DEBUG] rt_tablebuilder_nextrow: submitting row with 1 columns
DEBUG:  [RUNTIME:TRACE] add_tuple_to_result: called with value=1
DEBUG:  [RUNTIME:TRACE] add_tuple_to_result: numComputedColumns=1
DEBUG:  [RUNTIME:DEBUG] add_tuple_to_result: Streaming computed results
DEBUG:  [RUNTIME:TRACE] process_computed_results: col[0] type=16 null=false
DEBUG:  [RUNTIME:TRACE] process_computed_results: streaming returned true
DEBUG:  [RUNTIME:DEBUG] rt_tablebuilder_nextrow: reset column index to 0 for row 1
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid called with iterator: 0x5925fb2e4150
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid: iter=0x5925fb2e4150, table_handle=0x5925fb2e2180
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid: About to call read_next_tuple_from_table
DEBUG:  [RUNTIME:TRACE] read_next_tuple_from_table: About to call heap_getnext with scanDesc=0x5925fb2e4390
DEBUG:  [RUNTIME:TRACE] read_next_tuple_from_table: scanDesc->rs_rd=0x791df525e7f0, snapshot=0x5925fb229ae0
DEBUG:  [RUNTIME:TRACE] read_next_tuple_from_table: heap_getnext completed, tuple=0x5925fb2e43e8
DEBUG:  [RUNTIME:TRACE] read_next_tuple_from_table: About to process tuple, cleaning up previous tuple
DEBUG:  [RUNTIME:TRACE] read_next_tuple_from_table: Tuple preserved for streaming
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid: read_result = 1
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid: column 0 (flag2) from PG column 2 = true (null=false)
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid finished running with: 0x5925fb2e4150 branch 2
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access called with iterator: 0x5925fb2e4150, row_data: 0x7ffc1f5e3258
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access: row_data is valid, proceeding
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access: handling 1 columns
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access: column 0 is_null=false, valid_bitmap=0xFF
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access: column 0 (flag2) boolean = true at 0x5925fb48ad80
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access: configured 1 columns successfully
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access completed successfully
DEBUG:  [RUNTIME:TRACE] table_builder_add<bool>: byte value=0xFE (254), normalized=0
DEBUG:  [RUNTIME:DEBUG] table_builder_add: storing value at column index 0 with is_null=false
DEBUG:  [RUNTIME:DEBUG] rt_tablebuilder_nextrow: LingoDB column validation passed - 1 columns filled
DEBUG:  [RUNTIME:DEBUG] rt_tablebuilder_nextrow: submitting row with 1 columns
DEBUG:  [RUNTIME:TRACE] add_tuple_to_result: called with value=1
DEBUG:  [RUNTIME:TRACE] add_tuple_to_result: numComputedColumns=1
DEBUG:  [RUNTIME:DEBUG] add_tuple_to_result: Streaming computed results
DEBUG:  [RUNTIME:TRACE] process_computed_results: col[0] type=16 null=false
DEBUG:  [RUNTIME:TRACE] process_computed_results: streaming returned true
DEBUG:  [RUNTIME:DEBUG] rt_tablebuilder_nextrow: reset column index to 0 for row 2
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid called with iterator: 0x5925fb2e4150
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid: iter=0x5925fb2e4150, table_handle=0x5925fb2e2180
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid: About to call read_next_tuple_from_table
DEBUG:  [RUNTIME:TRACE] read_next_tuple_from_table: About to call heap_getnext with scanDesc=0x5925fb2e4390
DEBUG:  [RUNTIME:TRACE] read_next_tuple_from_table: scanDesc->rs_rd=0x791df525e7f0, snapshot=0x5925fb229ae0
DEBUG:  [RUNTIME:TRACE] read_next_tuple_from_table: heap_getnext completed, tuple=0x5925fb2e43e8
DEBUG:  [RUNTIME:TRACE] read_next_tuple_from_table: About to process tuple, cleaning up previous tuple
DEBUG:  [RUNTIME:TRACE] read_next_tuple_from_table: Tuple preserved for streaming
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid: read_result = 1
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid: column 0 (flag2) from PG column 2 = true (null=false)
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid finished running with: 0x5925fb2e4150 branch 2
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access called with iterator: 0x5925fb2e4150, row_data: 0x7ffc1f5e3258
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access: row_data is valid, proceeding
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access: handling 1 columns
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access: column 0 is_null=false, valid_bitmap=0xFF
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access: column 0 (flag2) boolean = true at 0x5925fb48ad80
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access: configured 1 columns successfully
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access completed successfully
DEBUG:  [RUNTIME:TRACE] table_builder_add<bool>: byte value=0xFE (254), normalized=0
DEBUG:  [RUNTIME:DEBUG] table_builder_add: storing value at column index 0 with is_null=false
DEBUG:  [RUNTIME:DEBUG] rt_tablebuilder_nextrow: LingoDB column validation passed - 1 columns filled
DEBUG:  [RUNTIME:DEBUG] rt_tablebuilder_nextrow: submitting row with 1 columns
DEBUG:  [RUNTIME:TRACE] add_tuple_to_result: called with value=1
DEBUG:  [RUNTIME:TRACE] add_tuple_to_result: numComputedColumns=1
DEBUG:  [RUNTIME:DEBUG] add_tuple_to_result: Streaming computed results
DEBUG:  [RUNTIME:TRACE] process_computed_results: col[0] type=16 null=false
DEBUG:  [RUNTIME:TRACE] process_computed_results: streaming returned true
DEBUG:  [RUNTIME:DEBUG] rt_tablebuilder_nextrow: reset column index to 0 for row 3
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid called with iterator: 0x5925fb2e4150
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid: iter=0x5925fb2e4150, table_handle=0x5925fb2e2180
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid: About to call read_next_tuple_from_table
DEBUG:  [RUNTIME:TRACE] read_next_tuple_from_table: About to call heap_getnext with scanDesc=0x5925fb2e4390
DEBUG:  [RUNTIME:TRACE] read_next_tuple_from_table: scanDesc->rs_rd=0x791df525e7f0, snapshot=0x5925fb229ae0
DEBUG:  [RUNTIME:TRACE] read_next_tuple_from_table: heap_getnext completed, tuple=0x5925fb2e43e8
DEBUG:  [RUNTIME:TRACE] read_next_tuple_from_table: About to process tuple, cleaning up previous tuple
DEBUG:  [RUNTIME:TRACE] read_next_tuple_from_table: Tuple preserved for streaming
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid: read_result = 1
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid: column 0 (flag2) from PG column 2 = false (null=false)
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid finished running with: 0x5925fb2e4150 branch 2
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access called with iterator: 0x5925fb2e4150, row_data: 0x7ffc1f5e3258
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access: row_data is valid, proceeding
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access: handling 1 columns
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access: column 0 is_null=false, valid_bitmap=0xFF
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access: column 0 (flag2) boolean = false at 0x5925fb48ad80
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access: configured 1 columns successfully
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access completed successfully
DEBUG:  [RUNTIME:TRACE] table_builder_add<bool>: byte value=0xFF (255), normalized=1
DEBUG:  [RUNTIME:DEBUG] table_builder_add: storing value at column index 0 with is_null=false
DEBUG:  [RUNTIME:DEBUG] rt_tablebuilder_nextrow: LingoDB column validation passed - 1 columns filled
DEBUG:  [RUNTIME:DEBUG] rt_tablebuilder_nextrow: submitting row with 1 columns
DEBUG:  [RUNTIME:TRACE] add_tuple_to_result: called with value=1
DEBUG:  [RUNTIME:TRACE] add_tuple_to_result: numComputedColumns=1
DEBUG:  [RUNTIME:DEBUG] add_tuple_to_result: Streaming computed results
DEBUG:  [RUNTIME:TRACE] process_computed_results: col[0] type=16 null=false
DEBUG:  [RUNTIME:TRACE] process_computed_results: streaming returned true
DEBUG:  [RUNTIME:DEBUG] rt_tablebuilder_nextrow: reset column index to 0 for row 4
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid called with iterator: 0x5925fb2e4150
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid: iter=0x5925fb2e4150, table_handle=0x5925fb2e2180
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid: About to call read_next_tuple_from_table
DEBUG:  [RUNTIME:TRACE] read_next_tuple_from_table: About to call heap_getnext with scanDesc=0x5925fb2e4390
DEBUG:  [RUNTIME:TRACE] read_next_tuple_from_table: scanDesc->rs_rd=0x791df525e7f0, snapshot=0x5925fb229ae0
DEBUG:  [RUNTIME:TRACE] read_next_tuple_from_table: heap_getnext completed, tuple=0x5925fb2e43e8
DEBUG:  [RUNTIME:TRACE] read_next_tuple_from_table: About to process tuple, cleaning up previous tuple
DEBUG:  [RUNTIME:TRACE] read_next_tuple_from_table: Tuple preserved for streaming
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid: read_result = 1
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid: column 0 (flag2) from PG column 2 = false (null=false)
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid finished running with: 0x5925fb2e4150 branch 2
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access called with iterator: 0x5925fb2e4150, row_data: 0x7ffc1f5e3258
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access: row_data is valid, proceeding
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access: handling 1 columns
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access: column 0 is_null=false, valid_bitmap=0xFF
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access: column 0 (flag2) boolean = false at 0x5925fb48ad80
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access: configured 1 columns successfully
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_access completed successfully
DEBUG:  [RUNTIME:TRACE] table_builder_add<bool>: byte value=0xFF (255), normalized=1
DEBUG:  [RUNTIME:DEBUG] table_builder_add: storing value at column index 0 with is_null=false
DEBUG:  [RUNTIME:DEBUG] rt_tablebuilder_nextrow: LingoDB column validation passed - 1 columns filled
DEBUG:  [RUNTIME:DEBUG] rt_tablebuilder_nextrow: submitting row with 1 columns
DEBUG:  [RUNTIME:TRACE] add_tuple_to_result: called with value=1
DEBUG:  [RUNTIME:TRACE] add_tuple_to_result: numComputedColumns=1
DEBUG:  [RUNTIME:DEBUG] add_tuple_to_result: Streaming computed results
DEBUG:  [RUNTIME:TRACE] process_computed_results: col[0] type=16 null=false
DEBUG:  [RUNTIME:TRACE] process_computed_results: streaming returned true
DEBUG:  [RUNTIME:DEBUG] rt_tablebuilder_nextrow: reset column index to 0 for row 5
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid called with iterator: 0x5925fb2e4150
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid: iter=0x5925fb2e4150, table_handle=0x5925fb2e2180
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid: About to call read_next_tuple_from_table
DEBUG:  [RUNTIME:TRACE] read_next_tuple_from_table: About to call heap_getnext with scanDesc=0x5925fb2e4390
DEBUG:  [RUNTIME:TRACE] read_next_tuple_from_table: scanDesc->rs_rd=0x791df525e7f0, snapshot=0x5925fb229ae0
DEBUG:  [RUNTIME:TRACE] read_next_tuple_from_table: heap_getnext completed, tuple=(nil)
DEBUG:  [RUNTIME:DEBUG] read_next_tuple_from_table: heap_getnext returned null - end of table
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid: read_result = 0
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_isvalid finished running with: 0x5925fb2e4150 branch 3
DEBUG:  [RUNTIME:DEBUG] close_postgres_table called with handle: 0x5925fb2e2180
DEBUG:  [RUNTIME:DEBUG] close_postgres_table: Closing JIT-managed table scan
DEBUG:  [RUNTIME:DEBUG] close_postgres_table: Resetting g_jit_table_oid from 10681270 to InvalidOid
DEBUG:  [RUNTIME:DEBUG] rt_datasourceiteration_end: cleanup will be handled by MemoryContextCallback
DEBUG:  [RUNTIME:DEBUG] AFTER: g_jit_results_ready = 1
DEBUG:  [RUNTIME:TRACE] Validation: g_computed_results.numComputedColumns = 1
DEBUG:  [RUNTIME:TRACE] Validation: First computed value = 1
DEBUG:  [JIT:DEBUG] JIT function execution completed
DEBUG:  [JIT:DEBUG] JIT execution took 0.691 ms
DEBUG:  [JIT:DEBUG] JIT execution completed successfully
DEBUG:  [JIT:DEBUG] JIT query execution completed successfully
DEBUG:  [JIT:DEBUG] Destroying JIT execution handle
DEBUG:  [GENERAL:DEBUG] mlir_runner::run_mlir_with_dest_receiver returned true
DEBUG:  [JIT:DEBUG] JIT returned successfully, checking results...
DEBUG:  [JIT:DEBUG] g_jit_results_ready = true
DEBUG:  [JIT:DEBUG] JIT execution successful - results already streamed by JIT
DEBUG:  [GENERAL:DEBUG] run_mlir_with_ast_translation completed, returning true
DEBUG:  [GENERAL:DEBUG] MyCppExecutor::execute completed, returning true
 not_flag2 
-----------
         1
         0
         0
         1
         1
(5 rows)

-- Disable debug logging
SET client_min_messages TO NOTICE;
SET pgx_lower.log_enable = false;
SELECT (flag1 AND flag2 AND value > 25) AS complex_and FROM test_logical;
NOTICE:  [PGX-LOWER] Routing through PGX_LOWER compilation
 complex_and 
-------------
           0
           0
           0
           0
           0
(5 rows)

SELECT (flag1 OR flag2 OR value < 15) AS complex_or FROM test_logical;
NOTICE:  [PGX-LOWER] Routing through PGX_LOWER compilation
 complex_or 
------------
          0
          0
          0
          0
          0
(5 rows)

DROP TABLE test_logical;
